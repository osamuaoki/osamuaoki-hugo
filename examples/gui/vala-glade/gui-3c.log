$ valac -C --pkg gtk+-3.0 --pkg gmodule-2.0 gui-3.vala
gui-3.vala:8.5-8.34: warning: method `HelloWorld.on_button1_clicked' never used
    public void on_button1_clicked (Button button) {
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
gui-3.vala:14.5-14.34: warning: method `HelloWorld.on_window1_destroy' never used...
    public void on_window1_destroy (Window window) {
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Compilation succeeded - 2 warning(s)
$ wc -l gui-3.vala ; wc -l gui-3.c
40 gui-3.vala
220 gui-3.c
$ cat gui-3.c |sed -e 's/       /    /g'|fold
/* gui-3.c generated by valac 0.20.1, the Vala compiler
 * generated from gui-3.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define TYPE_HELLO_WORLD (hello_world_get_type ())
#define HELLO_WORLD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HELLO_WORLD, H
elloWorld))
#define HELLO_WORLD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HELLO_W
ORLD, HelloWorldClass))
#define IS_HELLO_WORLD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HELLO_WORLD
))
#define IS_HELLO_WORLD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HELL
O_WORLD))
#define HELLO_WORLD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HELLO
_WORLD, HelloWorldClass))

typedef struct _HelloWorld HelloWorld;
typedef struct _HelloWorldClass HelloWorldClass;
typedef struct _HelloWorldPrivate HelloWorldPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (va
r), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var),
NULL)))

struct _HelloWorld {
    GObject parent_instance;
    HelloWorldPrivate * priv;
};

struct _HelloWorldClass {
    GObjectClass parent_class;
};

struct _HelloWorldPrivate {
    gint i;
};


static gpointer hello_world_parent_class = NULL;

GType hello_world_get_type (void) G_GNUC_CONST;
#define HELLO_WORLD_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_HELLO
_WORLD, HelloWorldPrivate))
enum  {
    HELLO_WORLD_DUMMY_PROPERTY
};
void hello_world_on_button1_clicked (GtkButton* button, HelloWorld* self);
void hello_world_on_window1_destroy (GtkWindow* window, HelloWorld* self);
gint hello_world_run (HelloWorld* self, gchar** args, int args_length1);
HelloWorld* hello_world_new (void);
HelloWorld* hello_world_construct (GType object_type);
static void hello_world_finalize (GObject* obj);
gint _vala_main (gchar** args, int args_length1);


void hello_world_on_button1_clicked (GtkButton* button, HelloWorld* self) {
    gint _tmp0_;
    GtkButton* _tmp1_;
    gint _tmp2_;
    gchar* _tmp3_ = NULL;
    gchar* _tmp4_;
    g_return_if_fail (self != NULL);
    g_return_if_fail (button != NULL);
    _tmp0_ = self->priv->i;
    self->priv->i = _tmp0_ + 1;
    _tmp1_ = button;
    _tmp2_ = self->priv->i;
    _tmp3_ = g_strdup_printf ("Hello, World!\nClick count = %i", _tmp2_);
    _tmp4_ = _tmp3_;
    gtk_button_set_label (_tmp1_, _tmp4_);
    _g_free0 (_tmp4_);
}


void hello_world_on_window1_destroy (GtkWindow* window, HelloWorld* self) {
    g_return_if_fail (self != NULL);
    g_return_if_fail (window != NULL);
    gtk_main_quit ();
}


static gpointer _g_object_ref0 (gpointer self) {
    return self ? g_object_ref (self) : NULL;
}


gint hello_world_run (HelloWorld* self, gchar** args, int args_length1) {
    gint result = 0;
    GError * _inner_error_ = NULL;
    g_return_val_if_fail (self != NULL, 0);
    self->priv->i = 0;
    {
        GtkBuilder* _tmp0_;
        GtkBuilder* builder;
        GtkBuilder* _tmp1_;
        GtkBuilder* _tmp2_;
        GObject* _tmp3_ = NULL;
        GtkWindow* _tmp4_;
        GtkWindow* window;
        GtkBuilder* _tmp5_;
        GtkBuilder* _tmp6_;
        GtkWindow* _tmp7_;
        _tmp0_ = gtk_builder_new ();
        builder = _tmp0_;
        _tmp1_ = builder;
        gtk_builder_add_from_file (_tmp1_, "clickme-ext.glade", &_inner_error_);
        if (_inner_error_ != NULL) {
            _g_object_unref0 (builder);
            goto __catch0_g_error;
        }
        _tmp2_ = builder;
        _tmp3_ = gtk_builder_get_object (_tmp2_, "window1");
        _tmp4_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, GTK_TYPE_WI
NDOW) ? ((GtkWindow*) _tmp3_) : NULL);
        window = _tmp4_;
        _tmp5_ = builder;
        _tmp6_ = builder;
        gtk_builder_connect_signals (_tmp5_, _tmp6_);
        _tmp7_ = window;
        gtk_widget_show_all ((GtkWidget*) _tmp7_);
        _g_object_unref0 (window);
        _g_object_unref0 (builder);
    }
    goto __finally0;
    __catch0_g_error:
    {
        GError* e = NULL;
        FILE* _tmp8_;
        GError* _tmp9_;
        const gchar* _tmp10_;
        e = _inner_error_;
        _inner_error_ = NULL;
        _tmp8_ = stderr;
        _tmp9_ = e;
        _tmp10_ = _tmp9_->message;
        fprintf (_tmp8_, "Could not load UI: %s\n", _tmp10_);
        result = 1;
        _g_error_free0 (e);
        return result;
    }
    __finally0:
    if (_inner_error_ != NULL) {
        g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, _
_LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inn
er_error_->code);
        g_clear_error (&_inner_error_);
        return 0;
    }
    result = 0;
    return result;
}


HelloWorld* hello_world_construct (GType object_type) {
    HelloWorld * self = NULL;
    self = (HelloWorld*) g_object_new (object_type, NULL);
    return self;
}


HelloWorld* hello_world_new (void) {
    return hello_world_construct (TYPE_HELLO_WORLD);
}


static void hello_world_class_init (HelloWorldClass * klass) {
    hello_world_parent_class = g_type_class_peek_parent (klass);
    g_type_class_add_private (klass, sizeof (HelloWorldPrivate));
    G_OBJECT_CLASS (klass)->finalize = hello_world_finalize;
}


static void hello_world_instance_init (HelloWorld * self) {
    self->priv = HELLO_WORLD_GET_PRIVATE (self);
}


static void hello_world_finalize (GObject* obj) {
    HelloWorld * self;
    self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_HELLO_WORLD, HelloWorld);
    G_OBJECT_CLASS (hello_world_parent_class)->finalize (obj);
}


GType hello_world_get_type (void) {
    static volatile gsize hello_world_type_id__volatile = 0;
    if (g_once_init_enter (&hello_world_type_id__volatile)) {
        static const GTypeInfo g_define_type_info = { sizeof (HelloWorldClass),
(GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) hello_world_cla
ss_init, (GClassFinalizeFunc) NULL, NULL, sizeof (HelloWorld), 0, (GInstanceInit
Func) hello_world_instance_init, NULL };
        GType hello_world_type_id;
        hello_world_type_id = g_type_register_static (G_TYPE_OBJECT, "HelloWorld
", &g_define_type_info, 0);
        g_once_init_leave (&hello_world_type_id__volatile, hello_world_type_id);
    }
    return hello_world_type_id__volatile;
}


gint _vala_main (gchar** args, int args_length1) {
    gint result = 0;
    HelloWorld* _tmp0_;
    HelloWorld* h;
    gchar** _tmp1_;
    gint _tmp1__length1;
    gtk_init (&args_length1, &args);
    _tmp0_ = hello_world_new ();
    h = _tmp0_;
    _tmp1_ = args;
    _tmp1__length1 = args_length1;
    hello_world_run (h, _tmp1_, _tmp1__length1);
    gtk_main ();
    result = 0;
    _g_object_unref0 (h);
    return result;
}


int main (int argc, char ** argv) {
    g_type_init ();
    return _vala_main (argv, argc);
}



