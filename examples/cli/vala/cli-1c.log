$ valac -C cli-1.vala
$ wc -l cli-1.vala ; wc -l cli-1.c
75 cli-1.vala
221 cli-1.c
$ cat cli-1.c |sed -e 's/       /    /g'|fold  # tab => 4 spaces
/* cli-1.c generated by valac 0.20.1, the Vala compiler
 * generated from cli-1.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <stdio.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_co
ntext_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var),
NULL)))


extern gboolean append;
gboolean append = FALSE;
extern gboolean verbose;
gboolean verbose = FALSE;
extern gboolean op_long;
gboolean op_long = FALSE;
extern gchar* filename;
gchar* filename = NULL;
extern gchar* longextra;
gchar* longextra = NULL;
extern gchar** sources;
gchar** sources = NULL;

gint _vala_main (gchar** args, int args_length1);
static gint _vala_array_length (gpointer array);

const GOptionEntry options[7] = {{"append", 'a', 0, G_OPTION_ARG_NONE, &append,
"Set append mode", NULL}, {"verbose", 'v', 0, G_OPTION_ARG_NONE, &verbose, "Set
verbose mode", NULL}, {"file", 'f', 0, G_OPTION_ARG_FILENAME, &filename, "Use F
file", "F"}, {"long", (gchar) 0, 0, G_OPTION_ARG_NONE, &op_long, "Set long mode"
, NULL}, {"longextra", (gchar) 0, 0, G_OPTION_ARG_STRING, &longextra, "Set longe
xtra to M", "M"}, {"", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &sources, NULL
, "FILE..."}, {NULL}};

gint _vala_main (gchar** args, int args_length1) {
    gint result = 0;
    FILE* _tmp0_;
    gchar** _tmp1_;
    gint _tmp1__length1;
    const gchar* _tmp2_;
    FILE* _tmp3_;
    gchar** _tmp4_;
    gint _tmp4__length1;
    const gchar* _tmp5_;
    gchar* _tmp6_ = NULL;
    gchar* _tmp7_;
    gboolean _tmp18_;
    gboolean _tmp20_;
    gboolean _tmp22_;
    const gchar* _tmp24_;
    const gchar* _tmp27_;
    gchar** _tmp30_;
    gint _tmp30__length1;
    GError * _inner_error_ = NULL;
    setlocale (LC_ALL, "");
    _tmp0_ = stdout;
    _tmp1_ = args;
    _tmp1__length1 = args_length1;
    _tmp2_ = _tmp1_[0];
    fprintf (_tmp0_, "command  = %s\n", _tmp2_);
    _tmp3_ = stdout;
    _tmp4_ = args;
    _tmp4__length1 = args_length1;
    _tmp5_ = _tmp4_[0];
    _tmp6_ = g_path_get_basename (_tmp5_);
    _tmp7_ = _tmp6_;
    fprintf (_tmp3_, "basename = %s\n", _tmp7_);
    _g_free0 (_tmp7_);
    {
        GOptionContext* _tmp8_;
        GOptionContext* opt_context;
        GOptionContext* _tmp9_;
        GOptionContext* _tmp10_;
        GOptionContext* _tmp11_;
        _tmp8_ = g_option_context_new ("- Cli");
        opt_context = _tmp8_;
        _tmp9_ = opt_context;
        g_option_context_set_help_enabled (_tmp9_, TRUE);
        _tmp10_ = opt_context;
        g_option_context_add_main_entries (_tmp10_, options, NULL);
        _tmp11_ = opt_context;
        g_option_context_parse (_tmp11_, &args_length1, &args, &_inner_error_);
        if (_inner_error_ != NULL) {
            _g_option_context_free0 (opt_context);
            if (_inner_error_->domain == G_OPTION_ERROR) {
                goto __catch0_g_option_error;
            }
            _g_option_context_free0 (opt_context);
            g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FIL
E__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain)
, _inner_error_->code);
            g_clear_error (&_inner_error_);
            return 0;
        }
        _g_option_context_free0 (opt_context);
    }
    goto __finally0;
    __catch0_g_option_error:
    {
        GError* e = NULL;
        FILE* _tmp12_;
        GError* _tmp13_;
        const gchar* _tmp14_;
        FILE* _tmp15_;
        gchar** _tmp16_;
        gint _tmp16__length1;
        const gchar* _tmp17_;
        e = _inner_error_;
        _inner_error_ = NULL;
        _tmp12_ = stdout;
        _tmp13_ = e;
        _tmp14_ = _tmp13_->message;
        fprintf (_tmp12_, "%s\n", _tmp14_);
        _tmp15_ = stdout;
        _tmp16_ = args;
        _tmp16__length1 = args_length1;
        _tmp17_ = _tmp16_[0];
        fprintf (_tmp15_, "Run '%s --help' to see a full list of available comma
nd line options.\n", _tmp17_);
        result = 1;
        _g_error_free0 (e);
        return result;
    }
    __finally0:
    if (_inner_error_ != NULL) {
        g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, _
_LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inn
er_error_->code);
        g_clear_error (&_inner_error_);
        return 0;
    }
    _tmp18_ = verbose;
    if (_tmp18_) {
        FILE* _tmp19_;
        _tmp19_ = stdout;
        fprintf (_tmp19_, "Cli: verbose ON\n");
    }
    _tmp20_ = append;
    if (_tmp20_) {
        FILE* _tmp21_;
        _tmp21_ = stdout;
        fprintf (_tmp21_, "Cli: appemd ON\n");
    }
    _tmp22_ = op_long;
    if (_tmp22_) {
        FILE* _tmp23_;
        _tmp23_ = stdout;
        fprintf (_tmp23_, "Cli: long ON\n");
    }
    _tmp24_ = filename;
    if (_tmp24_ != NULL) {
        FILE* _tmp25_;
        const gchar* _tmp26_;
        _tmp25_ = stdout;
        _tmp26_ = filename;
        fprintf (_tmp25_, "Cli: file = %s\n", _tmp26_);
    }
    _tmp27_ = longextra;
    if (_tmp27_ != NULL) {
        FILE* _tmp28_;
        const gchar* _tmp29_;
        _tmp28_ = stdout;
        _tmp29_ = longextra;
        fprintf (_tmp28_, "Cli: longextra = %s\n", _tmp29_);
    }
    _tmp30_ = sources;
    _tmp30__length1 = _vala_array_length (sources);
    if (_tmp30_ != NULL) {
        gint i;
        gchar** _tmp31_;
        gint _tmp31__length1;
        i = 0;
        _tmp31_ = sources;
        _tmp31__length1 = _vala_array_length (sources);
        {
            gchar** s_collection = NULL;
            gint s_collection_length1 = 0;
            gint _s_collection_size_ = 0;
            gint s_it = 0;
            s_collection = _tmp31_;
            s_collection_length1 = _tmp31__length1;
            for (s_it = 0; s_it < _tmp31__length1; s_it = s_it + 1) {
                gchar* _tmp32_;
                gchar* s = NULL;
                _tmp32_ = g_strdup (s_collection[s_it]);
                s = _tmp32_;
                {
                    FILE* _tmp33_;
                    gint _tmp34_;
                    const gchar* _tmp35_;
                    gint _tmp36_;
                    _tmp33_ = stdout;
                    _tmp34_ = i;
                    _tmp35_ = s;
                    fprintf (_tmp33_, "sources[%i]=%s\n", _tmp34_, _tmp35_);
                    _tmp36_ = i;
                    i = _tmp36_ + 1;
                    _g_free0 (s);
                }
            }
        }
    }
    result = 0;
    return result;
}


int main (int argc, char ** argv) {
    g_type_init ();
    return _vala_main (argv, argc);
}


static gint _vala_array_length (gpointer array) {
    int length;
    length = 0;
    if (array) {
        while (((gpointer*) array)[length]) {
            length++;
        }
    }
    return length;
}



