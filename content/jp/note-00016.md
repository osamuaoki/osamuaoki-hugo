---
title: ATmega328P (2)
date: 2020-03-03
categories:
  - DIY
  - japanese
tags:
  - avrdude
slug: ATmega328P-2
---

Arduino Uno/Nano に使われている基本のシリアルAVRの
[ATmega328P](https://www.microchip.com/wwwproducts/en/ATmega328p)
を中心としてAVRチップのプログラムの練習の続きをしました。


## 開発環境

クロスコンパイル開発環境は以下でOK（2020/03, Debian stable buster）


```
 $ sudo apt install gcc-avr avr-libc binutils-avr
```

## 開発例: Lチカ点滅


まず、単純なLEDのBLINKを例に開発しましょう。


### Cのソースコード

以下にいわゆるLチカ `blink.c`を例示します。これでNanoのPB5ピンに
ぶら下がっているLEDを0.5秒間隔でON/OFFします。

```
// Arduino nano board is 16 MHz
#define F_CPU 16000000UL

#include <avr/io.h>
#include <util/delay.h>

int
main (void) {
    // For Data Direction Register of port B, set the 5th bit (OR)
    DDRB |= _BV(DDB5);
    while(1)
    {
        // For Port B, toggle the 5th bit (XOR)
        PORTB ^= _BV(PORTB5);
        _delay_ms(500); // 500 ms delay
    }
}

```

ここで普通のCのプログラムでは見かけないマクロの`_BV()`や、
よく分からない変数`DDRB`等が気になります。

AVRクロスコンパイル開発環境では、普通を違い`/usr/lib/avr/include/`下に
inclideファイルがあります。これさえ分かれば後はコードを見ればほぼ自明です。


例えば`_BV()`は、基本のヘッダーファイル`avr/io.h`が読み込む
`avr/sfr_defs.h`中に定義されています。


```
#define _BV(bit) (1 << (bit))
```

ところで、見慣れない変数名ですがその答えは、`avr/io.h`や`avr/sfr_defs.h`
を読むと見えてきます。ちなみに、`avr/io.h`はチップのIO（入出力）の定義の
ヘッダーファイルで、`avr/sfr_defs.h`は「AVR special function registers」
の定義のヘッダーファイルです。

これらのヘッダーファイルは、xmega等もサポートするために少々複雑になって
いますが、ザックリはchipのdatasheetを読んでIOポートの物理アドレスを調べ
てプログラムを書かなくとも、データーシートの「ポートの名前」等をCの変数
名として使えるようにするCマクロの仕組みです。

`io.h`がコンパイル時に`-mmcu=atmega328p`で選ばれたチップ毎に合わせて
`iom328p.h`などの対応する定義ファイルをinclideすることで異なるハード
ウエアーへの対応を実現しています。

ポートの名前は、
[ATmega328Pのデーターシート](http://ww1.microchip.com/downloads/en/DeviceDoc/ATmega48A-PA-88A-PA-168A-PA-328-P-DS-DS40002061A.pdf)
の「Register Description」の章を見ましょう。例えば：

* `DDRB`は、Port B の Data Direction Register（データー入出力方向レジスター）
    * 「0」WRITE、入力ポートに設定 (デフォルト)
    * 「1」WRITE、出力ポートに設定
    *  READ:　設定値の読み出し
* `PORTB`は、Port B の Data Register (出力レジスター)
    * 「0」WRITE、出力ポート: LOW (0V)設定  / 入力ポート: Pull-up OFF 設定 (デフォルト)
    * 「1」WRITE、出力ポート: HIGH (VCC)設定 / 入力ポート: Pull-up ON 設定
    *  READ:　設定値の読み出し
* `PINB`は、Port B の Input Pins Address (入力レジスター)　入力・出力ポートとも有効
    * 「0」WRITE: ビット設定値の無変更
    * 「1」WRITE: ビット設定値の変更（トグル）
    *  READ:　入力値の読み出し

一方`_BV(bit)`の`bit`に書かれるマクロの値は文字列の最後の数字その物
のことが多いです。データーシート中のビットの名前に合わせてあるので
チップ間で不規則な面があります。ある程度コードのポータビリティー
のための変数名エリアスが`iom328p.h`に定義されています。

この他のマニュアル、特に
[AVR42787: AVR Software User Guide](http://ww1.microchip.com/downloads/en/Appnotes/Atmel-42787-AVR-Software-User-Guide_ApplicationNote_AVR42787.pdf)
や
[AVR035: Efficient C Coding for AVR](http://ww1.microchip.com/downloads/en/Appnotes/doc1497.pdf)
等にも目を通しましょう。


### コンパイル・リンク・プログラム


[AVRISP mkII をISP接続](/jp/2020/02/21/atmega328p-1/)した上で
コンパイル・リンク・プログラムは次の様に進めます。


```
 $ avr-gcc -mmcu=atmega328p -Wall -Os -o blink.elf blink.c
 $ avr-objcopy -j .text -j .data -O ihex blink.elf blink.hex
 $ sudo avrdude -p m328p -c avrisp2 -e -U flash:w:blink.hex
```

どうですか、Lチカしていますね。


## Lピカー点灯


ビット値が1が、出力がHIGHであることを確認しましょう。上記ソースコードを
以下の様に変更します。

```
// Arduino nano board is 16 MHz
#define F_CPU 16000000UL

#include <avr/io.h>

int
main (void) {
    // For Data Direction Register of port B, set the 5th bit (OR)
    DDRB |= _BV(DDB5);
    // For Port B, turn on the 5th bit (OR)
    PORTB |= _BV(PORTB5);
    while(1)
    {
        _delay_ms(500); // 500 ms delay
    }
}

```

同様のコンパイル・リンク・プログラムをします。

どうですか、今度はLEDが付きっぱなしですね。


## Makefile

毎回シェルにコマンドを打ち込むのも面倒です。

こういった基本的な開発環境では、`Makefile`を使いたいですよね。
`Makefile`の基本テンプレートは以下がよく使われます。

```
 $ sudo apt install subversion
 $ svn checkout https://svn.code.sf.net/p/winavr/code/trunk winavr-code
```

Linux系の開発環境だとGNU Make を使うので、この中の
`winavr-code/Mfile/data/makefile_template.winavr`
が基本テンプレートとなります。これをソース内に
`Makefile`にコピーして書き換えて使います。


<!-- vim: se ai tw=79: -->
