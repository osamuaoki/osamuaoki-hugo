---
title: ATmega328P (3)
date: 2020-03-06
categories:
  - DIY
  - japanese
tags:
  - avrdude
slug: ATmega328P-3
---

前回に続きArduino Uno/Nano に使われている基本のシリアルAVRの
[ATmega328P](https://www.microchip.com/wwwproducts/en/ATmega328p)
を中心としてAVRチップのプログラムの勉強・練習の続きとして、
「AVR Libc Reference Manual」を読み込んでAVR独特の世界をみました。

## メモリー

PCでのプログラムとはメモリー関係は、少々勝手が違い、IO関係を直接触る上、
メモリー空間も狭いので要注意です。

さらにATmega328Pを含むAVRはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀに対してﾒﾓﾘとﾊﾞｽを分離する
ﾊｰﾊﾞｰﾄﾞ構造を使用し、メモリーアドレス空間もそれぞれ別です。
（PCはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀがメモリーアドレス空間を共有するノイマン構造。）

* ﾌﾟﾛｸﾞﾗﾑは不揮発性のフラッシュに格納されます。
* ﾃﾞｰﾀは通常の揮発性のSRAMに格納されます。
* 不揮発データーを格納する別のEEPROMもあります。

ATmega328Pだと：

* ﾌﾗｯｼｭ ﾒﾓﾘ容量 (ﾊﾞｲﾄ) 32K
* SRAM容量 (ﾊﾞｲﾄ) 2K
* EEPROM容量 (ﾊﾞｲﾄ) 1K

実際のデーターメモリー領域は以下です。

* ﾚｼﾞｽﾀ ﾌｧｲﾙ    (32: 0x00-0x1F)　ーALUの汎用レジスタ
* I/Oﾚｼﾞｽﾀ      (64: 0x20-0x5F) - アセンブラIN/OUT命令は0x20オフセットしたLDS/STS
* 拡張I/Oﾚｼﾞｽﾀ (160: 0x60-0xFF)
* 内蔵SRAM      (2K: 0x100-0x3FFF)

IN/OUT命令関連のことがよく分からない。どうもAVRの前の世代のマイコン8051の命令
のことのようだ。アセンブラコード移植を意識しているようだ。INTEL系はIOは0x00から
始まる独立アドレス空間なので、アセンブラコードは0x20オフセットした
LDS/STS命令に置き換えると言っているようです。

ﾌﾟﾛｸﾞﾗﾑ領域（フラッシュ）へのアクセスには専用のアセンブラコードLPM/SPMがあります。

EEPROM領域へのアクセスは専用のI/Oﾚｼﾞｽﾀ経由で行うようです。

Cコードからは、マクロが準備されているので、ﾌﾟﾛｸﾞﾗﾑ領域たやEEPROM領域へのアクセス
には専用マクロ等を使うようだ。詳しくは「ATmega328Pマニュアル」の「ﾃﾞｰﾀ用EEPROMﾒﾓﾘ」や、
「AVR Libc Reference Manual」の「Data in Program Space」や、
`avr/eeprom.h` や `avr/pgmspace.h`を参照しましょう。

また、AVRはﾊｰﾊﾞｰﾄﾞ構造なので、リンカーに渡すデーターメモリーの開始アドレス
は実際のアドレスに0x800000 を手動で加えることも要注意です。

## メモリー消費の確認

メモリー消費は、以下のコマンドで調べます。フラッシュ消費は「Program」、
SRAM消費は「Data」で示されます。SRAMの初期化データーをフラッシュが
保持するため、「.text」がダブルカウントされます。

```
 $ avr-size --mcu=atmega328p --format=avr blink.elf
AVR Memory Usage
----------------
Device: atmega328p

Program:     162 bytes (0.5% Full)
(.text + .data + .bootloader)

Data:          0 bytes (0.0% Full)
(.data + .bss + .noinit)
```

## メモリー消費の節約

通常変数はデーターメモリー領域に置かれますが、場所をとる文字定数や
配列となったデーターベースはプログラムメモリー領域のフラッシュに置き
貴重なSRAMの使用を節約したいころです。

`PROGMEM`マクロや `PSTR`マクロや `PGM_P`マクロや `pgm_read_byte()`
関数はそのためにあります。

`puts_P()` や `fprint_P()`等というサフックス付き変種関数は、
ﾌﾟﾛｸﾞﾗﾑ領域（フラッシュ）に置いた文字列を出力文字列やフォーマット
文字列として利用しながら`puts()` や `fprint()`という相当する標準
関数と同等の機能を提供します。

また、`malloc()`を使用するのはメモリー消費の節約の点で好ましく
無いのでこれを避ける標準入出力を作る仕組みを提供するために
`FDEV_SETUP_STREAM()`マクロなどが提供されています。

この辺はAVR独特の世界の詳細なので、標準ストリームと併せて実例で学びましょう。

## 標準ストリーム

もうひとつのAVR独特の世界は標準ストリームです。

C標準とは違い、avr-libcには適用できるデバイス情報がないため、
標準ストリーム`stdin`、`stdout`と`stderr`のストリームは
アプリケーション起動時に事前に初期化されません。

これもAVR独特の世界の詳細なので、メモリーと併せて実例で学びましょう。

## AVR独特の世界の例

... WIP ...



<!-- vim: se ai tw=79: -->
