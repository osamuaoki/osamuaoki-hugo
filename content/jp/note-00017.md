---
title: ATmega328P (3)
date: 2020-03-06
categories:
  - DIY
  - japanese
tags:
  - avrdude
slug: ATmega328P-3
---

前回に続きArduino Uno/Nano に使われている基本のシリアルAVRの
[ATmega328P](https://www.microchip.com/wwwproducts/en/ATmega328p)
を中心としてAVRチップのプログラムの勉強・練習の続きとして、
「AVR Libc Reference Manual」を読み込んでAVR独特の世界をみました。

## メモリー

PCでのプログラムとはメモリー関係は、少々勝手が違い、IO関係を直接触る上、
メモリー空間も狭いので要注意です。

さらにATmega328Pを含むAVRはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀに対してﾒﾓﾘとﾊﾞｽを分離する
ﾊｰﾊﾞｰﾄﾞ構造を使用し、メモリーアドレス空間もそれぞれ別です。
（PCはﾌﾟﾛｸﾞﾗﾑとﾃﾞｰﾀがメモリーアドレス空間を共有するノイマン構造。）

* ﾌﾟﾛｸﾞﾗﾑは不揮発性のフラッシュに格納されます。
* ﾃﾞｰﾀは通常の揮発性のSRAMに格納されます。
* 不揮発データーを格納する別のEEPROMもあります。

ATmega328Pだと：

* ﾌﾗｯｼｭ ﾒﾓﾘ容量 (ﾊﾞｲﾄ) 32K
* SRAM容量 (ﾊﾞｲﾄ) 2K
* EEPROM容量 (ﾊﾞｲﾄ) 1K

実際のデーターメモリー領域は以下です。

* ﾚｼﾞｽﾀ ﾌｧｲﾙ    (32: 0x00-0x1F)　ーALUの汎用レジスタ
* I/Oﾚｼﾞｽﾀ      (64: 0x20-0x5F) - アセンブラIN/OUT命令は0x20オフセットしたLDS/STS
* 拡張I/Oﾚｼﾞｽﾀ (160: 0x60-0xFF)
* 内蔵SRAM      (2K: 0x100-0x3FFF)

IN/OUT命令関連のことがよく分からない。どうもAVRの前の世代のマイコン8051の命令
のことのようだ。アセンブラコード移植を意識しているようだ。INTEL系はIOは0x00から
始まる独立アドレス空間なので、アセンブラコードは0x20オフセットした
LDS/STS命令に置き換えると言っているようです。

ﾌﾟﾛｸﾞﾗﾑ領域（フラッシュ）へのアクセスには専用のアセンブラコードLPM/SPMがあります。

EEPROM領域へのアクセスは専用のI/Oﾚｼﾞｽﾀ経由で行うようです。

Cコードからは、マクロが準備されているので、ﾌﾟﾛｸﾞﾗﾑ領域たやEEPROM領域へのアクセス
には専用マクロ等を使うようだ。詳しくは「ATmega328Pマニュアル」の「ﾃﾞｰﾀ用EEPROMﾒﾓﾘ」や、
「AVR Libc Reference Manual」の「Data in Program Space」や、
`avr/eeprom.h` や `avr/pgmspace.h`を参照しましょう。

また、AVRはﾊｰﾊﾞｰﾄﾞ構造なので、リンカーに渡すデーターメモリーの開始アドレス
は実際のアドレスに0x800000 を手動で加えることも要注意です。

## メモリー消費の確認

メモリー消費は、以下のコマンドで調べます。フラッシュ消費は「Program」、
SRAM消費は「Data」で示されます。SRAMの初期化データーをフラッシュが
保持するため、「.text」がダブルカウントされます。

```
 $ avr-size --mcu=atmega328p --format=avr blink.elf
AVR Memory Usage
----------------
Device: atmega328p

Program:     162 bytes (0.5% Full)
(.text + .data + .bootloader)

Data:          0 bytes (0.0% Full)
(.data + .bss + .noinit)
```

## メモリー消費の節約

通常変数はデーターメモリー領域に置かれますが、場所をとる文字定数や
配列となったデーターベースはプログラムメモリー領域のフラッシュに置き
貴重なSRAMの使用を節約したいころです。

`PROGMEM`マクロや `PSTR`マクロや `PGM_P`マクロや `pgm_read_byte()`
関数はそのためにあります。これらは「Program Space Utilities」として
`avr/pgmspace.h`により提供されています。

`puts_P()` や `fprint_P()`等というサフックス付き変種関数は、
ﾌﾟﾛｸﾞﾗﾑ領域（フラッシュ）に置いた文字列を出力文字列やフォーマット
文字列として利用しながら`puts()` や `fprint()`という相当する標準
関数と同等の機能を提供します。これらの変種関数も含めて
標準の「Standard IO facilities」として`stdio.h`により提供されています。

また、`stdio.h`は、`malloc()`を使用するのはメモリー消費の節約の点で
好ましく無いのでこれを避ける標準入出力を作る仕組みを提供するために
`FDEV_SETUP_STREAM()`マクロなどが提供されています。

この辺はAVR独特の世界の詳細なので、他と併せて実例で学びましょう。

## 標準ストリーム

もうひとつのAVR独特の世界は標準ストリームです。

C標準とは違い、avr-libcには適用できるデバイス情報がないため、
標準ストリーム`stdin`、`stdout`と`stderr`のストリームは
アプリケーション起動時に事前に初期化されません。

これもAVR独特の世界の詳細なので、他と併せて実例で学びましょう。


## 標準ライブラリ

ATmega328Pはavr5なので、リンクされる標準ライブラリのバイナリは
`/usr/lib/avr/lib/avr5/`にあります。ライブラリが標準ライブラリの
`libc.a`と数学関数ライブラリの`libm.a`と分かれているのは普通だし
チップ対応の`libatmega328p.a`があるのは分かりますが、
`libprintf_flt.a`や`libprintf_min.a`や`libscanf_flt.a`や
`libscanf_min.a`が気になります。

これらは、`printf()`や`scanf()`関連機能をコンパイラオプションで
制限・拡張することで、無駄にメモリー消費しないために存在します。
標準では使いそうにない浮動小数点関係のフォーマット機能は削られ
ています。まあ普通のAVR使用環境ではこれで充分です。

必要になったら「AVR Libc Reference Manual」の
「<stdio.h>: Standard IO facilities」の `vfprintf()`と
`vfscanf()`の説明のそれぞれの最後の部分を精読しましょう。

## AVR独特の世界の例

「AVR Libc Reference Manual」のデモプロジェクトは、
`/usr/share/doc/avr-libc/examples/`にあります。

これを参考に、「LEDタイマー点灯」に加筆して、端子入力に合わせて
シリアルに「Hello」等とゆっくり出力する簡単なプログラムの
`hello.c`を作成しました。（シリアル出力なしで、デモコードより簡単です。）

```
// Arduino nano board is 16 MHz
#define F_CPU 16000000UL
#define BAUD 115200
// Usable Baud Rate 300 600 1200 2400 4800 9600 14400 19200 28800 38400 57600 115200
// $ picocom -b 115200 /dev/ttyUSB0
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <util/setbaud.h>
#include <stdio.h>

static void
uart_init(void)
{
UBRR0H = UBRRH_VALUE;
UBRR0L = UBRRL_VALUE;
#if USE_2X
UCSR0A |= (1 << U2X0);
#else
UCSR0A &= ~(1 << U2X0);
#endif
/* async, non-parity, 1-bit stop, 8-bit data */
UCSR0C = _BV(UCSZ01)|_BV(UCSZ00);
/* transmitter enable */
UCSR0B = _BV(TXEN0);
}

int
uart_putchar(char c, FILE *stream)
{
    if (c == '\n') {
        uart_putchar('\r', stream);
    }
    loop_until_bit_is_set(UCSR0A, UDRE0);
    UDR0 = c;
    return 0;
}

#define SURE_LO 0
#define UNSURE  1
#define SURE_HI 2
#define BIT5HI  0b00100000

FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);

int
check (void) {
    // Check if any one of low 5 bits 01234 of PORTB is grounded
    if ((PINB & 0x1f) != 0x1f) {
        _delay_ms(50); // 50 ms delay
        if ((PINB & 0x1f) != 0x1f) {
            return SURE_LO;
        }
    }
    // Check if all low 5 bits 01234 of PORTB are not grounded
    else if ((PINB & 0x1f) == 0x1f) {
        _delay_ms(50); // 50 ms delay
        if ((PINB & 0x1f) == 0x1f) {
            return SURE_HI;
        }
    }
    return UNSURE;
}

int
main (void) {
    int previous = SURE_HI; // pull-uped
    uart_init();
    stdout = &uart_str;
    // For Data Direction Register of port B, set 5 pin as output for LED
    DDRB = BIT5HI;
    // pull-up for all port B non-5 pins (0b11011111)
    PORTB = ~ BIT5HI;
    while(1) {
        if ((previous == SURE_HI) & (check() == SURE_LO)) {
            // LED ON
            PORTB |=   BIT5HI;
            printf_P(PSTR("Hello world! "));
            for (int i=1; i < 10; i++) {
                _delay_ms(100); // 100 ms delay
                printf_P(PSTR("-"));
            }
            // LED OFF
            PORTB &= ~ BIT5HI;
            printf_P(PSTR("> Bye world!\n"));
            previous = SURE_LO;
        } else if ((previous == SURE_LO) & (check() == SURE_HI)) {
            previous = SURE_HI;
        }
    }
}
```

ハードウエアーに対応するレジスター名やビットの名前がAVRの世代毎に違うためか
「AVR Libc Reference Manual」のデモプロジェクトにコードはそのままでは動き
ませんでした。さらに、レジスター名等もデーターシートとも微妙に異なっていま
した。最後はデーターシートとヘッダーファイルの定義を見比べて、微妙に数字を
加えたりの名前の合わせ込みをしました。

デモコードより正確なボーレート計算を`util/setbaud.h`を使ってしました。

さて、これをコンパイルしてできる`hello.hex`を、USB経由でチップに以下で
プログラムしました。

```
$ sudo avrdude -p m328p -c arduino -P /dev/ttyUSB0 -U flash:w:blink.hex
```

USBをつないだまま、以下を実行し、「LEDタイマー点灯」と同様の端子の接地
をするとホストPCに文字列が印字されました。


```
 $ picocom -b 115200 /dev/ttyUSB0
picocom v3.1

port is        : /dev/ttyUSB0
flowcontrol    : none
baudrate is    : 115200
parity is      : none
databits are   : 8
stopbits are   : 1
escape is      : C-a
local echo is  : no
noinit is      : no
noreset is     : no
hangup is      : no
nolock is      : no
send_cmd is    : sz -vv
receive_cmd is : rz -vv -E
imap is        :
omap is        :
emap is        : crcrlf,delbs,
logfile is     : none
initstring     : none
exit_after is  : not set
exit is        : no

Type [C-a] [C-h] to see available commands
Terminal ready
Hello world! ---------> Bye world!
Hello world! ---------> Bye world!
```






<!-- vim: se ai tw=79: -->
