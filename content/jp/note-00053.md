---
title: PC付属キーマップ改善準備
date: 2022-06-03
categories:
  - iot
  - japanese
tags:
  - evdev
slug: evdev01
---

## キーボード状況

確かにQMKを使うと[自由にキーマップ]({{< ref "note-00047.md" >}})が構成でき、動きの少ない手や指にやさしいタイピングができます。

ただ、PC付属キーキーボードででも、同じように[HOME ROW MOD](https://precondition.github.io/home-row-mods)等ができないかと言う気になります。

[interception-tools](https://gitlab.com/interception/linux/tools)を利用し構成する可能性としてはありますが、まだ例が見当たりません。確かに`evdev`デバイスを通るデーターをフィルター変換で実現するという発想はありです。

ただ、正直分かりにくいので、まず読みやすいPythonの[chorded_keymap](https://gitlab.com/wsha/chorded_keymap)を見ました。実際にevdevを通るデーターの実態がよく分からなかったので、この中のプログラムをベースに[データーダンプするユーティリティー](https://github.com/osamuaoki/osamu-utils/blob/main/print_kbd_event)を作りました。

確かにほぼ同じ機能のコマンドevtestがあるんですが、この経験をしたことで実態がよく分かりました。

この出力は以下です。

```
 12577.98: MSC SCAN 0xcb / KEY LEFT → / SYN REPORT 0
 12577.996: MSC SCAN 0xcb / KEY LEFT ↑ / SYN REPORT 0
 12578.431: MSC SCAN 0xcd / KEY RIGHT ↓ / SYN REPORT 0
 12578.508: MSC SCAN 0xcd / KEY RIGHT ↑ / SYN REPORT 0
 12578.811: MSC SCAN 0xe / KEY BACKSPACE ↓ / SYN REPORT 0
 12578.878: MSC SCAN 0xe / KEY BACKSPACE ↑ / SYN REPORT 0
 12579.346: MSC SCAN 0x11 / KEY W ↓ / SYN REPORT 0
 12579.439: MSC SCAN 0x11 / KEY W ↑ / SYN REPORT 0
 12579.616: MSC SCAN 0x18 / KEY O ↓ / SYN REPORT 0
 12579.69: MSC SCAN 0x18 / KEY O ↑ / SYN REPORT 0
 12579.898: MSC SCAN 0x1c / KEY ENTER ↓ / SYN REPORT 0
 12579.976: MSC SCAN 0x1c / KEY ENTER ↑ / SYN REPORT 0
 12580.125: MSC SCAN 0x1f / KEY S ↓ / SYN REPORT 0
 12580.226: MSC SCAN 0x1f / KEY S ↑ / SYN REPORT 0
 12580.423: MSC SCAN 0x23 / KEY H ↓ / SYN REPORT 0
 12580.494: MSC SCAN 0x23 / KEY H ↑ / SYN REPORT 0
 12580.678: MSC SCAN 0x17 / KEY I ↓ / SYN REPORT 0
 12580.752: MSC SCAN 0x17 / KEY I ↑ / SYN REPORT 0
 12581.067: MSC SCAN 0x14 / KEY T ↓ / SYN REPORT 0
 12581.152: MSC SCAN 0x14 / KEY T ↑ / SYN REPORT 0
 12581.216: MSC SCAN 0x1e / KEY A ↓ / SYN REPORT 0
 12581.316: MSC SCAN 0x1e / KEY A ↑ / SYN REPORT 0
 12581.892: MSC SCAN 0x25 / KEY K ↓ / SYN REPORT 0
 12581.974: MSC SCAN 0x25 / KEY K ↑ / SYN REPORT 0
 12582.155: MSC SCAN 0x18 / KEY O ↓ / SYN REPORT 0
 12582.221: MSC SCAN 0x18 / KEY O ↑ / SYN REPORT 0
 12582.454: MSC SCAN 0x14 / KEY T ↓ / SYN REPORT 0
 12582.525: MSC SCAN 0x14 / KEY T ↑ / SYN REPORT 0
 12582.645: MSC SCAN 0x18 / KEY O ↓ / SYN REPORT 0
 12582.722: MSC SCAN 0x18 / KEY O ↑ / SYN REPORT 0
 12582.854: MSC SCAN 0x20 / KEY D ↓ / SYN REPORT 0
 12582.94: MSC SCAN 0x20 / KEY D ↑ / SYN REPORT 0
 12583.037: MSC SCAN 0x12 / KEY E ↓ / SYN REPORT 0
 12583.121: MSC SCAN 0x12 / KEY E ↑ / SYN REPORT 0
 12583.89: MSC SCAN 0x1c / KEY ENTER ↓ / SYN REPORT 0
 12584.01: MSC SCAN 0x1c / KEY ENTER ↑ / SYN REPORT 0
 12585.08: MSC SCAN 0xcd / KEY RIGHT ↓ / SYN REPORT 0
 12585.345: MSC SCAN 0xcd / KEY RIGHT → / SYN REPORT 0
 12585.378: MSC SCAN 0xcd / KEY RIGHT → / SYN REPORT 0
 12585.404: MSC SCAN 0xcd / KEY RIGHT → / SYN REPORT 0
 12585.436: MSC SCAN 0xcd / KEY RIGHT → / SYN REPORT 0
 12585.466: MSC SCAN 0xcd / KEY RIGHT → / SYN REPORT 0
 12585.497: MSC SCAN 0xcd / KEY RIGHT → / SYN REPORT 0
 12585.525: MSC SCAN 0xcd / KEY RIGHT → / SYN REPORT 0
 12585.555: MSC SCAN 0xcd / KEY RIGHT → / SYN REPORT 0

```
気づいたことは:
* キーを押すと、プレス(↓)となる。
* キーを長押しすると、250msぐらいで、リピート(→)となる。リピートは25ms毎ぐらい。
* キーを離すと、リリース(↑)となる。
* スキャンコードは普通使われない。
* `SYN REPORT 0`のおまじないが必ずある。

これを頭に、現在で回っている、フィルターを見てみました。

HOME-ROW-MODを考えるなら、CHORDED(併せ押し)ではなく、TAP-HOLD（押しの短長）アプローチです。ただ、それも[caps2esc](https://gitlab.com/interception/linux/plugins/caps2esc)等は、press=HOLDで、RELEASEでタイミングが200ms以下ならTAPを出す感じです。CAPSのような端のキーならまだしも、HOME-ROW-MODでこれをするとまともにタイプできません。

TAP-HOLD時間判断はプログラム内で管理が必要かと思っていましたが、あまりフィルターで使われていないリピート(→)を上手く利用すると複雑なEVENT処理無にできそうな気がします。

[Interception plugin for vimproved input](https://github.com/maricn/interception-vimproved) には、汎用性は無い形ですがレイヤー処理があります。(SPACE-fn)

[Dual Function Keys](https://gitlab.com/interception/linux/plugins/dual-function-keys)は、TAP-HOLDのスタートや他キーが早くPUSH・RELEASEされた際の対応はいい感じです。他にキー打鍵無い際のHOLD移行にタイマーかREPEATを使わないのは良くない気がします。タイミングチャートは参考になります。

[interception-k2k](https://github.com/zsugabubus/interception-k2k]は、汎用マッパーです。レイヤー機能はありません。設定ファイルがCですが、見通しがいいスタイルですね。REPEATにも対応してそうです。

<!-- vim: se ai tw=150: -->
