---
title: PC内蔵キーボードのキーマップ操作準備
date: 2022-06-03
categories:
  - iot
  - japanese
tags:
  - evdev
slug: evdev01
---

## キーボード状況

USB接続の自作外付けキーボードでは、[キーマップ]({{< ref "note-00047.md" >}})がQMKを使うと自由に構成でき、[HOME ROW MOD](https://precondition.github.io/home-row-mods)等を使うと動きの少ない手や指にやさしいタイピングができます。

PC内蔵のキーボードででも、同じようにできないかと言う気になり色々調査しました。

[interception-tools](https://gitlab.com/interception/linux/tools)を利用し構成する可能性としてはあるようですが、まだ良い例が見当たりません。確かに`evdev`デバイスを通るデーターをフィルター変換で実現するという発想はありです。

公式のプラグインの[Dual Function Keys](https://gitlab.com/interception/linux/plugins/dual-function-keys)には、[HOME ROW MODが上手く動作しない](https://gitlab.com/interception/linux/plugins/dual-function-keys/-/issues/6)ともかかれています。状況は簡単ではないようです。

ただ、正直状況や解決策が分かりにくいので、まず読みやすいPythonの[chorded_keymap](https://gitlab.com/wsha/chorded_keymap)を見ました。実際にevdevを通るデーターの実態がよく分からなかったので、この中のプログラムをベースにデーターダンプするユーティリティーを作り、更にもう一度出力をオプションでコントロール出きるように、最初から書き直して[manglekbd](https://github.com/osamuaoki/osamu-utils/blob/main/manglekbd)を作りました。確かにほぼ同じ機能のコマンドevtestがあるんですが、この経験をしたことで少し実態が分かりました。

この出力は以下です。

```
$ sudo intercept /dev/input/by-path/platform-i8042-serio-0-event-kbd | python3 manglekbd -s u
0.908776327	MSC,SCAN,0x1c	KEY,ENTER,↑	SYN,REPORT,0	
10.192124000	MSC,SCAN,0x1c	KEY,ENTER,↓	SYN,REPORT,0	

0.089146000	MSC,SCAN,0x1c	KEY,ENTER,↑	SYN,REPORT,0	
11.603746000	MSC,SCAN,0x39	KEY,SPACE,↓	SYN,REPORT,0	 
0.262023000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	
0.029101000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	
0.033056000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	
0.029728000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	
0.030239000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	
0.030332000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	
0.028457000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	
0.031279000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	 
0.029795000	MSC,SCAN,0x39	KEY,SPACE,→	SYN,REPORT,0	
0.010177000	MSC,SCAN,0x39	KEY,SPACE,↑	SYN,REPORT,0	
2.797907000	MSC,SCAN,0x23	KEY,H,↓	SYN,REPORT,0	h
0.071473000	MSC,SCAN,0x23	KEY,H,↑	SYN,REPORT,0	
0.090236000	MSC,SCAN,0x12	KEY,E,↓	SYN,REPORT,0	e
0.089604000	MSC,SCAN,0x12	KEY,E,↑	SYN,REPORT,0	
0.205702000	MSC,SCAN,0x26	KEY,L,↓	SYN,REPORT,0	l
0.065889000	MSC,SCAN,0x26	KEY,L,↑	SYN,REPORT,0	
0.093182000	MSC,SCAN,0x26	KEY,L,↓	SYN,REPORT,0	l
0.192301000	MSC,SCAN,0x26	KEY,L,↑	SYN,REPORT,0	
0.397202000	MSC,SCAN,0x18	KEY,O,↓	SYN,REPORT,0	o
0.194982000	MSC,SCAN,0x18	KEY,O,↑	SYN,REPORT,0	
2.839868000	MSC,SCAN,0x11	KEY,W,↓	SYN,REPORT,0	w
0.252236000	MSC,SCAN,0x11	KEY,W,→	SYN,REPORT,0	
0.012211000	MSC,SCAN,0x11	KEY,W,↑	SYN,REPORT,0	
10.691589000	MSC,SCAN,0x33	KEY,COMMA,↓	SYN,REPORT,0	,
0.035153000	MSC,SCAN,0x33	KEY,COMMA,↑	SYN,REPORT,0	

```
気づいたことは:
* キーを押すと、プレス(↓)となる。
* キーを長押しすると、250msぐらいで、リピート(→)となる。リピートは30ms毎ぐらい。
* リピート(→)が必ずしも有効追加打鍵にはならない。（最初8回は無視？、合計500ms後から実際の連続打鍵状態）
* キーを離すと、リリース(↑)となる。
* スキャンコードは普通使われないし、外付けキーボードではかなり違う。
* `SYN REPORT 0`のおまじないが必ずある。
* タイムスタンプはmsで、ほぼ必ずキーコードとSYNレポートがペアで同じタイムスタンプで時間順。

これを頭に、現在出回っている、フィルターを見てみました。

HOME-ROW-MODを考えるなら、CHORDED(併せ押し)ではなく、TAP-HOLD（押しの短長）アプローチです。ただ、それも[caps2esc](https://gitlab.com/interception/linux/plugins/caps2esc)等は、press=HOLDで、RELEASEでタイミングが200ms以下ならTAPを出す感じです。CAPSのような端のキーならまだしも、HOME-ROW-MODでこれをするとまともにタイプできません。

TAP-HOLD時間判断はプログラム内で管理が必要かと思っていましたが、あまりフィルターで使われていないリピート(→)を上手く利用すると複雑なEVENT処理をし無くとも実現できそうな気がします。

[Dual Function Keys](https://gitlab.com/interception/linux/plugins/dual-function-keys)は、基本イベント処理ループは`C`で書かれていて、YAML設定ファイルは`C++`で読み込んでいます。別にタイミングチャート図が有り参考になります。TAP-HOLDのスタートや他キーが早くPUSH・RELEASEされた際の対応はいい感じです。他にキー打鍵無い際のHOLD移行にタイマーかREPEATを使わないようなのは気になります。またこれが使うTAP-HOLDのルールーは上記の[HOME-ROW-MODで問題](https://gitlab.com/interception/linux/plugins/dual-function-keys/-/issues/6)の原因の気がします。

[Interception plugin for vimproved input](https://github.com/maricn/interception-vimproved) は、`C++`で書かれていて、汎用性は無い形でかかれていて、複雑でタイミングなど読みきれませんがレイヤー処理があります。(SPACE-fn)

[interception-k2k](https://github.com/zsugabubus/interception-k2k)は、基本イベント処理ループは`C`で書かれていて、設定ファイルはincludeファイルを使う汎用マッパーです。レイヤー機能はありません。設定ファイルがCですが、見通しがいいスタイルですね。REPEATにも対応してそうです。
(Makefileのターゲットの前提要件中に`|`を使ってORDER-ONLY-PREREQUISITESを規定するのははじめてみたので、ちょっとと惑いました。)

## キーボードのTAP-HOLDタイミング考察

TAP-HOLDの無いキーをそのまま通過させるとすると、キーボードのTAP-HOLDタイミングは、HOME-ROW-MODでは、端のキーでは望ましそうなimmediateタイプではなく、delayedタイプが必要な気がします。

 * immediate: immediate hold (capslock用)
 * delayed:   immediate pending state for the key (wait for B↑ or A→) (HOME-ROW-MOD用)

以下キータイミング図で、それぞれのあるべき動作を確認しました。

どうも、遅延処理の全面導入と、リピートの利用、シフト等の(早期)確定後のシフト解除時にタップが出なくする、等々が必要な感じです。

### 単一MT キーを使用時の遅延処理有無のタイミング図

```
A: as MT(KC_SHFT, KC_A)
  S: KC_SHFT
  A: KC_A

----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓             A↑

immediate:      S↓             S↑A↓A↑
delayed:        ??               A↓A↑
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                        A→        A↑

immediate:      S↓                                  S↑
delayed:        ??                        S↓        S↑
----------------------------------------------------------------------------------
```

### MTキーと普通キーを両方使用時に、普通キーに遅延処理しない際のベストケースのタイミング図

こうすると後から打ったキーが先に処理されるので問題山積。やはり次のセクションのように全てのキーを遅延処理するべきみたい。

```
A: as MT(KC_SHFT, KC_A)
  S: KC_SHFT  (後から打った他キーのリリースでもHOLDにする)
  A: KC_A
B: simple key　TAP無処理の場合 (これを遅延処理するなら、次のセクションのMT(KC_CTRL, KC_B)と同じ)

----------------------------------------------------------------------------------
                <---------200ms---------> (この条件でのシフト入力は高速タイプ対策上必要)
keyboard1:      A↓             A↑
keyboard2:         B↓ B↑

immediate:      S↓ B↓ B↑       S↑       (Aタップ扱いしない処理が必要)
delayed:        ?? B↓ B↑S↓     S↑       (Aタップ扱いしない処理が必要)
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms---------> (普通キーの遅延処理が無いと、MTキーで必然の逆順問題発生)
keyboard1:      A↓             A↑
keyboard2:                B↓             B↑

immediate:      S↓        B↓   S↑A↓A↑    B↑    (逆順出力問題＋シフト問題：HOME-ROW-MODで問題)
delayed:        ??        B↓   A↓A↑      B↑    (逆順出力問題)
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                      A→          A↑
keyboard2:         B↓ B↑

immediate:      S↓ B↓ B↑                            S↑
delayed:        ?? B↓ S↓B↑                          S↑  (シフト欠落問題)
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                      A→            A↑
keyboard2:                          B↓         B↑

immediate:      S↓                  B↓         B↑     S↑
delayed:        ??                  B↓  S↓     B↑     S↑  (シフト欠落問題)
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                      A→            A↑
keyboard2:                                   B↓  B↑

immediate:      S↓                           B↓  B↑   S↑
delayed:        ??                      S↓   B↓  B↑   S↑
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                      A→          A↑
keyboard2:                                   B↓          B↑

immediate:      S↓                           B↓     S↑   B↑
delayed:        ??                      S↓   B↓     S↑   B↑
----------------------------------------------------------------------------------
```

### MTキー同士の組み合わせ使用時のタイミング図（遅延処理有りのMTと普通キーとの組み合わせも含む）

遅延処理の待ちリストが必要。

```
A: as MT(KC_SHFT, KC_A)
  S: KC_SHFT
  A: KC_A
B: as MT(KC_CTRL, KC_B)
  C: KC_CTRL
  B: KC_B
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓             A↑
keyboard2:         B↓ B↑

immediate:      S↓    B↓B↑     S↑       (Aタップ扱いしない処理が必要)
delayed:        ?? ** S↓B↓B↑   S↑       (Aタップ扱いしない処理が必要)
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms---------> (逆順はMTキー同士では発生しない)
keyboard1:      A↓             A↑
keyboard2:                B↓             B↑

immediate:      S↓        **   S↑A↓A↑    B↓B↑ (シフト問題なし)
delayed:        ??        **   A↓A↑      B↓B↑
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                      A→          A↑
keyboard2:         B↓ B↑

immediate:      S↓    B↓B↑                          S↑
delayed:        ?? ** S↓B↓B↑                        S↑
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                      A→          A↑
keyboard2:                          B↓         B↑

immediate:      S↓                             B↓B↑ S↑
delayed:        ??                  **  S↓     B↓B↑ S↑
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                      A→            A↑
keyboard2:                                   B↓  B↑

immediate:      S↓                               B↓B↑ S↑
delayed:        ??                      S↓       B↓B↑ S↑
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
keyboard1:      A↓                      A→          A↑
keyboard2:                                   B↓            B↑

immediate:      S↓                                         B↓S↑B↑
delayed:        ??                      S↓   **            B↓S↑B↑
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
                                     <---------200ms--------->
keyboard1:      A↓                      A→          A↑
keyboard2:                          B↓                       B→        B↑

immediate:      S↓                  ??              S↑       C↓        C↑
delayed:        ??                  **  S↓          S↑       C↓        C↑
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
                <---------200ms--------->
                                     <---------200ms--------->
keyboard1:      A↓                      A→                       A→           A↑
keyboard2:                          B↓                       B→        B↑

immediate:      S↓                  ??                       C↓        C↑     S↑
delayed:        ??                  **  S↓                   C↓        C↑     S↑
----------------------------------------------------------------------------------
```

### フィルター作成のアプローチ考察

今後フィルタープログラム作成時に必要な配慮点をを列記します。

* 文字差替えの際には同一タイムスタンプのイベントのペア構造や時間順を壊さないようにしたい。
* フィルターによる処理は、論理的にまとまった比較的論理構造が簡単な処理の組み合わせの切り分けデバグできる多段階リレー処理としたい。
* 「スキャンコード」、「通常キーコード＋キーステート(D/U/R)」、「SYNレポート」の３つを１セットの1打鍵としまとめたうえで、処理したい。
  * この条件に合わないキーの例外処理は、ログ書き出ししあとで考える。
* 遅延処理の順番待ち管理は状態遷移は、初期(0)、未定(1)、タップ確定(2)、ホールド確定(3)、リリース確定(0)とし、状態遷移毎に処理手続きを決める。
* 1セットの打鍵にレイヤー状態を考慮し、状態遷移にあわせてアクションのシーケンスに置き換え処理したい。
  * アクションとは、キー出力（MTだと複数）や、LAYER状態の更新を意味する。
* 実際の出力は１セット打鍵分ごとにI/O FLUSH

### フィルターフィルター機能設定のアプローチ考察

evdevデーターのフィルター機能の設定ファイルをどうすべきかを考えました。

* 実行時に複雑なロジックを組みたくないので、できるだけ簡単なアクション指定のSTRUCTのMATRIXとして、簡単な構造としたい。
* evdevデーターのフィルターの設定ファイルは、ベタで書き下すと、ほとんど無変換なのでかなり冗長（128~256キー＊4レイヤーで512~1024行）。手動で書くのは辛い。
  * 前処理プログラムで短いデーターから設定ファイルを生成するようにし、手動で冗長な記述をしなくてもいいようにしたい。
  * 各キー毎にTAP時/HOLD時のアクションを決める。設定ファイルではTAP時とHOLD時のアクションが同じ時は簡便記述できるようにする。
  * 汎用性を持たすには、キーシーケンスのマクロ処理機能があると、ロックキー・一時シフトキーなども扱いやすそう。
* QMKのように物理状態からのキー出力ではなく、シリアル化されたデーター列の変換なので、キーデーター列異常は気になる。
  * キーデーター列異常時の対応は、実際に試してみないとわからない面がある。そういった意味でもキー状態異常の監視がプログラム化できるベースとなるので[manglekbd](https://github.com/osamuaoki/osamu-utils/blob/main/manglekbd)は面白い。
* 各キーポジション毎に状態を保存する大MATRIX変数で管理するのか、比較的短くてすみそうな処理待ち行列変数で対応するのかは考えどころ。

<!-- vim: se ai tw=150: -->
