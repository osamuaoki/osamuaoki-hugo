---
title: "GTK GUI with PyGObject (1)"
date: 2021-07-12
categories:
  - coding
  - english
tags:
  - python
  - gtk
slug: pygi-1
---

## GTK GUI situation

GTK3 GUI has been changing.  (Now 3.38.5)

[The Python GTK+ 3 Tutorial](https://python-gtk-3-tutorial.readthedocs.io/en/latest/menus.html)
(as of 2021-07) goes as:

> Gtk.UIManager, Gtk.Action, and Gtk.ActionGroup have been deprecated since
> GTK+ version 3.10 and should not be used in newly-written code. Use the
> Application framework instead.

I understand this is caused by
[App Menu Retirement](https://gitlab.gnome.org/GNOME/Initiatives/-/wikis/App-Menu-Retirement).
I see no Python based tutorial contents for creating modern
[Primary menu](https://developer.gnome.org/hig/stable/primary-menus.html.en)
etc.  How do I do it?
Unfortunately, many code examples
in the upstream source tree and the tutorial tend to contain old deprecated
practices.

I would like to use Glade with the Gtk.Builder class to program GUI with
minimum efforts instead of calling widget classes.

## Glade

Let me go step-by-step to use Glade to create GTK GUI.

In order to understand what each Glade component does, linked pages from the
corresponding listed classes in the Gtk 3.0's
[Class](https://lazka.github.io/pgi-docs/Gtk-3.0/class.html) page was
valuable and gave me the most current insights.

Each Glade component is spelled without "." while corresponding Gtk class name
has "." after "__Gtk__".

### Where to start GUI

Looking at the way Glade is designed, it looked like I should start creating
window design by clicking and moving item from selection in the top buttons to
the canvas.

Since I want a simple GUI,
[GtkWindow](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Window.html)
found under the "Toplevels" button seems to be a good one as the starting
object.  (For other items under the "Toplevels" button, they seem to offer
mostly pop-up window dialogue etc.  One exeption is
[GtkApplicationWindow](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/ApplicationWindow.html)
which accommodates capability to start program via DBus connection.)

How to create top bar embedded primary menu was tricky.  It looks like
[GtkHeaderBar](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/HeaderBar.html)
under the "Containers" button is the one.   To me, this should have been placed
under the "Toplevels" button. (I am using Glade 3.38.2)

Please note
[GtkMenuBar](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/MenuBar.html)
is not the one to use (marked as deprecated).

### How to fill widgets into GUI

Dividing area into smaller subdivided areas are mostly done by
[GtkBox](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Box.html)
or
[GtkGrid](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Grid.html)
under the "Containers" button.

As a starter, I put
[GtkBox](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Box.html)
and changed "Number of items" on the left panel to 7.

Then I placed
[GtkButton](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Button.html),
[GtkEntry](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Entry.html),
[GtkSearchEntry](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/SearchEntry.html),
[GtkSpinButton](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/SpinButton.html),
[GtkLabel](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Label.html),
[GtkTextView](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/TextView.html), and
[GtkFileChooserButton](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/FileChooserButton.html)
as an easy starter.

For
[GtkWindow](https://lazka.github.io/pgi-docs/Gtk-3.0/classes/Window.html),
clicking composite box next to ID entry box will change "ID" to "Class Name".
Let's put "SimpleGui" to "ID" or "Class Name" entry and see the difference in
XML.  Let's see the diff.
```
--- composite-off-ID.ui 2021-07-12 22:56:06.250484181 +0900
+++ composite-on-class.ui       2021-07-12 22:54:35.185207274 +0900
@@ -2,7 +2,7 @@
 <!-- Generated with glade 3.38.2 -->
 <interface>
   <requires lib="gtk+" version="3.24"/>
-  <object class="GtkWindow" id="SimpleGui">
+  <template class="SimpleGui" parent="GtkWindow">
     <property name="can-focus">False</property>
     <child>
       <object class="GtkBox">
@@ -95,5 +95,5 @@
         </child>
       </object>
     </child>
-  </object>
+  </template>
 </interface>
```

I set IDs for other widgets.

Hmm... I see.  Now, I can use decorator technique described in
[The Python GTK+ 3 Tutorial: 22.5.  Gtk.Template](https://python-gtk-3-tutorial.readthedocs.io/en/latest/builder.html#gtk-template).
This __Gtk.Template__ can't be found in
[PyGObject API Reference under Gtk 3.0 Â» Classes](https://lazka.github.io/pgi-docs/Gtk-3.0/classes.html).
I found the definition of this decorator in the __python3-gi__ package as
`/usr/lib/python3/dist-packages/gi/_gtktemplate.py` imported from
`/usr/lib/python3/dist-packages/gi/overrides/Gtk.py`.


Let's set the signal for the top level "SimpleGui" panel.  On right side panel
under "signal", go down to "GtkWidget" and then we enter "onDestroy" asthe
"destroy" signal handler.  For "button_example" widget, we enter
"onButtonPressed" as the "pressed" signal handler.  For "folder_example"
created by "GtkFileChooserButton", we enter
"onFolderSelected" as the "selection-changed" signal handler. 

![The Glade screen](/img/simple-gui-glade.png)

### How to create GUI program

Now we should be ready to use this from `simple.py`:

```
import gi

gi.require_version("Gtk", "3.0")
from gi.repository import Gtk


@Gtk.Template(filename="composite-on-class.ui")
class Window1(Gtk.Window):
    __gtype_name__ = "SimpleGui"

    @Gtk.Template.Callback()
    def onDestroy(self, *args):
        Gtk.main_quit()

    @Gtk.Template.Callback()
    def onButtonPressed(self, button):
        print("Hello World! " + button.get_label())

    @Gtk.Template.Callback()
    def onFolderSelected(self, widget):
        print("Folder: " + widget.get_filename())

window = Window1()
window.show()

Gtk.main()
```

Running this with `python3 simple.py` will start the GUI as:

![Run simple-gui](/img/simple-gui-run.png)

Not bad.  I am using signal handler which uses the call back function.

For fixed GUI component widgets, this is going to be similar.

<!-- vim: set sw=2 sts=2 ai si et tw=79 ft=markdown: -->
