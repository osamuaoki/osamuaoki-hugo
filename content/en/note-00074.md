---
title: "Re-learning Vim (8)"
date: 2024-06-04T00:00:00+00:00
categories:
  - desktop
  - english
tags:
  - vim
slug: vim-learn-8
---

## Nvim configuration retrospective

I have been updating Nvim configuration with LazyVim as described in
[Re-learning Vim (7)]({{< ref "note-00040.md" >}}) to make it behave as close
as plain Nvim.

I made further changes to [my forked LazyVim starter](https://github.com/osamuaoki/starter).

## Vim configuration touch-ups

In order to make my Vim experience to match my LazyVim/Nvim configuration as
much, I also updated my `~/.vimrc`.

* [osamu's ~/.vimrc file](https://github.com/osamuaoki/dot-vim/blob/master/.vimrc)

## Folding of markdown file

I have always used `gq` under visual line mode to rewrap range of lines within
`'textwidth`.  Since LazyVim sets `'formatexpr`, it doesn't work as expected
any more for some `'filetype` such as `markdown`.

Easy workaround is to use `gw` instead.

## Basics around quickfix list

### Command summary

I feel I need to revisit some key baseline Vim operation techniques beyond the
use of keyboard MACRO.

Let's look into "Quickfix list" and "location list".
* "Quickfix list" is a Vim global list.
* "Location list" is a window-local list.

"Quickfix list" and "location list" are essentially a jump table data generated by:

* error outputs from compiler invoked by `make`-program `:make`
* text search with internal regex `:vim /{pattern}/ ##`
* text search with external regex `:gr '{pattern>' ##`

| "quickfix list"    | "location list"     | functionality              |
|--------------------|---------------------|----------------------------|
| `:vim[grep]`         | `:lv[imgrep]`         | Vim internal search        |
| `:gr[ep]`            | `:lgr[ep]`            | Vim external search        |
| `:helpg[rep]`        | `:lh[elpgrep]`        | Help message search        |
| `:mak[e]`            | `:lmak[e]`            | Run `makeprg`                |
| `:cex[pr] {expr}`    | `:lex[pr] {expr}`     | Run `{expr}`                 |
| `:cope[n]`           | `:lop[en]`            | Open list of errors/matches |
| `:ccl[ose]`          | `:lcl[ose]`           | Close list of errors/matches |
| `:cdo {cmd}`         | `:ld[o] {cmd}`        | Execute `{cmd}` for all errors/matches |
| `:cc` [*nr*]             | `:ll` [*nr*]              | Display *nr*-th error/match |
| `:cn[ext]`           | `:ln[ext]`            | Display next error/match   |
| `:cp[revious]` or `:cN` | `:lp[revious]`  or `:lN` | Display previous error/match |
| `:cfir[st]`          | `:lfir[st]`           | Display first error/match |
| `:cla[st]`           | `:lla[st]`            | Display last error/match |
| `:cli[st]`           | `:lli[st]`            | List all errors/matches |
| `:col[der]`          | `:lol[der]`           | Open older list of errors/matches |
| `:cne[wer]`          | `:lne[wer]`           | Open newer list of errors/matches |

Here, `{cmd}` in the above for `:cdo` is Ex-command like `s/foo/bar/gc`.
`{cmd}` can contain `|` to concatenate several commands in Ex-mode.

LazyVim and my updated `~/.vimrc` map `[q` and `]q` to `:cprevious<cr>` and
`:cnext<cr>` for easy navigation based on quickfix list.

Unless I get to do very complicated things, I should be OK just using global
quickfix list.

I normally set `hidden` and `autowrite`, so forcing some command to jump to
different buffer is safe.

For customizing `:make` behavior, see:

* `:h 'makeprg` (currently `make` is used to generate input)
* `:h 'errorformat` (complicated match string used)

For customizing `:cexpr {expr}` behavior, see:

* `:h :cexpr` (Here, `{expr}` is like `system(grep -n xyz *)` is used to generate input)
* The same `:h 'errorformat` is used to parse the result of `{expr}`.

For customizing `:grep` behavior, see:

* `:h 'grepprg` (currently `rg\ --vimgrep` is used to generate input)
* `:h 'grepformat` (currently `%f:%l:%c:%m` filename:line_number:column_number:messsage)

### Ex-mode command line

There are special characters for EX-mode command line.

* `##` : substitute with all names in the argument list when executed
* `%` : substitute with the current file name when executed
* `<c-r>%` : insert the current file name to the command line
* `%<tab>` : insert the current file name to the command line

If the faster `rg` (`ripgrep` package) is used for `:grep`, it can easily offer
optimal recursive tree search from the current working tree by not-specifying
the target file in Ex-mode command line.

The wildcard expression such as `*`, `*.txt`, `**.md`, ..., parsed by the
underlining shell (Bash) may also be useful.

### Use case (manual changes)

* At shell prompt, enter: `vi file1.txt file2.txt`
* In Vim/Nvim normal mode, enter `: gr 'pattern' ##`
* Open quickfix window with `:copen`
* Move and press within quickfix window to jump to matching location in target files.
* Use `]q` or `[q` to navigate in target files and make manual changes.
* Close quickfix window with `:cclose`
* Save all and quit with `:wqa`

### Use case (automatic changes)

* At shell prompt, enter: `vi file1.txt file2.txt`
* In Vim/Nvim normal mode, enter `:gr 'pattern' ##`
* Substitute all with confirmation with `:cdo 's/pattern/subststring/gc'`
* Save all and quit with `:wqa`

### Filter quickfix list contents

Use `exclude_pattern` and `include_pattern` (vim internal regex).

* ...
* Load `cfilter` with: `:packadd cfilter` (if not done yet)
* Remove matched from quickfix list with `:Cfilter! /exclude_pattern/`
* Select matched in quickfix list with `:Cfilter /include_pattern/`

(I updated `~/.vimrc` and `~/.config/nvim/lua/config/lazy.lua`)

This is quite handy to trim down quickfix list to run `:cdo {cmd}` script.

`:col` and `:cnew` are handy for this type of operation.

### Regex dialects around quickfix list

* Case sensitive regex:
  * `(?-i)` in the pattern for `rg` (POSIX 1003.2 regular expressions)
  * `\C` in the pattern for Vim internal
  * `-i` in the command option for grep
* Case **in**sensitive regex:
  * `(?i)` in the pattern for `rg` (POSIX 1003.2 regular expressions)
  * `\c` in the pattern for Vim internal
  * `--no-ignore-case` in the command option for grep

All modern platforms, such as Perl, Python, Rust, ..., support POSIX 1003.2
regular expressions.  So be careful for Vim RE.

Since I use `rg` or Vim internal regex, I decided to keep their default to be
smart case and set them as needed to be specific ones.

## Lua in Nvim basics

There are 4 ways to print the value of an internal variable `var` in
NORMAL-mode.

* `:lua vim.print(var)`
* `:lua print(vim.inspect(var))`
* `:lua =var`
* `:=var`

Here are tutorials:

* "[Lua-guide](https://neovim.io/doc/user/lua-guide.html)" for Nvim
* "[Lua 5.1 Reference Manual](https://lua.org/manual/5.1/)" for language

"Lua-guide" in the above is based on "[nvim-lua-guide](https://github.com/nanotee/nvim-lua-guide)" and supersede it now.

### Nvim logging

Invoke with option: `nvim -V10logfile.txt file1 file2`

`:=_G` should dump code to log.  Other variables can be inspected, too.

## Basic modules in LazyVim

I went through [LazyVim's keymap page](https://www.lazyvim.org/keymaps) to
check available non-extra modules and functionalities.

I found a few interesting ones which I overlooked.

### noice.nvim

I now realize noice.nvim offers a nice UI for recalling messages from the
message history, etc.  (Updated keymap.)

### todo-comments.nvim

Interesting search UI with quickfix.  Keyword are followed by a colon:

* `TODO:` do something
* `FIX:` this should be fixed
* `HACK:` weird code warning

### trouble.nvim

Interesting diagnostic and LSP UI with quickfix and telescope.

### conform.nvim and nvim-lint

These packages seem to replace functionality previously available through
null-ls/none-ls.

* Formatting is via conform.nvim
* Linting is via nvim-lint

### bufferline.nvim
LazyVim uses buffers with top tab line indicator.


<!--
### LSP

TODO: XXX --- start inlay hint disabled

LSP/inlay_hint
NVIM
https://www.reddit.com/r/neovim/comments/18y4bhz/neovim_inlay_hints_only_enable_if_i_first_run_a/
https://www.reddit.com/r/neovim/comments/14e41rb/today_on_nightly_native_lsp_inlay_hint_support/
https://www.reddit.com/r/neovim/comments/lqj21o/how_to_temporarily_disable_lsp/
https://www.reddit.com/r/neovim/comments/txtmdi/disable_neovim_lsp_for_specific_project/
https://github.com/shivamashtikar/configs/commit/da6305ee7221ad4fbdbbad4f11c35f4e56348175#diff-63dd48d2b3b9938a860c3d6af608d0706787dfdc0c31c172f8e5b4b7abdecf86R49

EMACS https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/
-->

## Additional plugins
### precognition.nvim

I added precognition with its feature disabled as started.

<!--
precognition -- offset for inlay_hint expected soon.
https://www.reddit.com/r/neovim/comments/1choy6e/introducing_precognitionnvim_know_where_you_want/
https://github.com/tris203/precognition.nvim/pull/38
-->

## Changes of LazyVim and extras

In order to understand historical context of LazyVim development, I checked:

* [NEWS.md](https://github.com/LazyVim/LazyVim/blob/main/NEWS.md)
* [CHANGELOG.md](https://github.com/LazyVim/LazyVim/blob/main/CHANGELOG.md) by searching on "`BREAKING CHANGES`".

These gave me decent perspective.

Then, I realize
[lua/lazyvim/util/plugin.lua](https://github.com/LazyVim/LazyVim/blob/main/lua/lazyvim/util/plugin.lua)
has interesting summary of reasons of existences for some extras --
deprecated/renamed/... .

<!-- vim: set sw=4 sts=4 ai si et tw=79 ft=markdown: -->
