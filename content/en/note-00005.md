---
title: "Re-learning Vim (1)"
date: 2019-09-17
categories:
  - vim
  - english
tags:
  - vim
slug: vim-learn-1
---

I can use Vim as a basic editor with TKL-keyboard while tapping some keys
multiple times.  Functional but not elegant!

I decided to re-learn Vim to use it *properly*.  Here is my learning memo.

## Concept

* Use default vim (minimum configuration, if possible).
  * Use as much native functionalities.
* 50%/60%-keyboard ready.
  * No cursor keys.

## Guiding voice

Here are a few insightful recommendations for the best practices for Vim.

* Voice of Vim God (Vim upstream: Bram Moolenaar): [Seven habits of effective text editing](https://www.moolenaar.net/habits.html)
* Voice of Vim Gurus: [#vim Recommendations](https://www.vi-improved.org/recommendations/)
* Voice of reference [vim-galore](https://github.com/mhinz/vim-galore) of which
  I don't agree some tips.
* [RTFM](https://vimhelp.org/) or `vim "+h|only"`.

## NORMAL MODE

Unlike other editors, the existence of NORMAL MODE is what makes Vim as the
great editor which demands minimum access to the ALT-key and CTRL-key.

### Cheat sheet

Here is my cheat sheet to remind me of all the important key strokes used
around NORMAL MODE with emphasis on motion keys:

```
 NORMAL MODE:        Goto BOF → gg      r +--- Next Char
 screen                   n N # ?ααα   e / +-- End of Word (non-alnum)
 scroll        ai+wW({[<sp"'`↓  ^b    t / / +- Word Next (non-alnum)
 ↓     Change c{motion} cc  c↑  ^u   n / / / + End of Word (space)
 ↓     Delete d{motion} dd  d↑  H   e / / / / +Word Next (space)
 +--+  Copy   y{motion} yy  y↑  {  C / / / / / +Till α, x  Delete char
 |zt|  Put After/Before p / P   ( / / / / / / / Find α, r  Replace char
 |^e|  "α  Use α as register    k/ / / / / / /  / EOL,  ~  Change case
 |zz|     0 ^ Fα Tα gE B ge b h M l e w E W tα fα $    gd  Goto definiton
 |^y| ↓↓↓ Split Window ↓↓↓      j ←--- Line            ^]  Tag jump
 |zb| ^W + ncsvhjkl=+-_<>|      ) ←--- Sentence        ^t  Tag jump-back
 +--+ Join lines       J        } ←--- Paragraph       ^o  Jump back
      Forward Backward Search   L ←--- Bottom of Page  {visual}>  Indent →
      n N /ααα ?ααα ← Find ααα  ^d ←-- Prev 1/2 Page   {visual}<  Indent ←
      n N *    # ←--- Indicator ^f ←-- Next Page       {visual}=  Indent ⇆
      , ; tα   Tα ←-- Till α    /ααα ← Find ααα * n N  {visual}gq Format Text
      , ; fα   Fα ←-- Find α    G ←--- Goto EOF
   Next Prev   %  ←-- Match     [{ ]} [[ ]] [] ][ Look for {}
 Record: qα, End-Record: q, Play-Record: @α, Mark as α: mα, Jump to α: `α/'α
 Undo: u, Redo: ^r, Repeat: . , Fold: Open zo/zO/zr/zR, Close zc/zC/zm/zM
 Insert Mode: i/a Before/After Char, I/A Before/After Line, O/o above/below
 Visual Mode: v Char V Line ^V Block, Replace Mode: R, Normal mode: <ESC>
```

This is intentionally terse. I found key sequences such as `3w`, `bd$`, `ciw`,
`3yaw`, … quite useful.

### Hints for memorizing key strokes

Some key assignments looks confusing.  Here are my hints for memorizing such
key strokes.

* Cursor move keys
  * `j` shape points to downward.
  * `k` shape points to upward.
* Screen scroll keys:
  * `^b`: Backward page
  * `^u`: Upward 1/2 page
  * `^y`: expose up 1 line == Yester(day)-line, next to ^u (Keep cursor)
  * `^f`: Forward  page
  * `^d`: Downward 1/2 page
  * `^e`: Expose down 1 line, next to ^d (Keep cursor)

### Interesting commands

* `ga`: Get Unicode point (HEX etc.)
* `g8`: Get Binary data HEX sequence
* `^G`: Get cursor Position
* `{visual}g?`: ROT13

### Remap keys

I remap SPACE-key as leader-key in NORMAL since it has no practical use and
easier access than default `\`-key.

```
let mapleader = ' '
```

### Some options

I tend to set as follows in the vim startup file (`~.vimrc` or its equivalent):

```
" make vim copy buffer bigger (default 50 lines: viminfo='100,<50,s10,h)
set viminfo='100,<5000,s100,h

" Allow to move cursor beyond for block
set virtualedit=block

```

## INSERT MODE

INSERT MODE is intuitive with cursor keys.

### Cool inputs with Control keys

* `^H`: Delete a character before the cursor. (\<BS>)
* `^W`: Delete the word before the cursor.
* `^U`: Delete all entered characters before the cursor.
* `^P`: Find previous keyword.(map non-starter \<S-TAB> to this)
* `^N`: Find next keyword.    (map non-starter \<TAB> to this)
* `^Y`: Insert the character which is above the cursor.
* `^E`: Insert the character which is below the cursor.
* `^T`: Insert one shiftwidth of indent.
* `^D`: Delete one shiftwidth of indent.
* `0^D`: Delete all indent.
* `^Vxαα`: Insert character at 0xαα.
* `^Vuαααα`: Insert Unicode character at 0xαααα.
* `^VUαααααα`: Insert Unicode character at 0xαααααααα.


### Remap non-starter TAB

I remap non-starter TAB following the vim manual (`:h ins-completion`):

```
" Auto complete <C-N> with <TAB> in non-BOL
"
function! CleverTab()
   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
      return "\<Tab>"
   else
      return "\<C-N>"
   endif
endfunction
inoremap <Tab> <C-R>=CleverTab()<CR>
" Auto complete <C-P> with <S-TAB> in non-BOL
"
function! CleverSTab()
   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
      return "\<S-Tab>"
   else
      return "\<C-P>"
   endif
endfunction
inoremap <S-Tab> <C-R>=CleverSTab()<CR>
```
### Remap to ESC

Pressing ESC-key is a bit stressful since it is far from the finger home
position.  I remap a quick key sequence `kj` to ESC-key.

```
inoremap kj  <Esc>
```


<!-- vim: set sw=2 sts=2 ai si et tw=79 ft=markdown: -->
