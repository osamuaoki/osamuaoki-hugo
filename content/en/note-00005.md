---
title: "Re-learning Vim (1)"
date: 2019-09-17
categories:
  - vim
  - english
tags:
  - vim
slug: vim-learn-1
---

I could use Vim as a basic editor with TKL-keyboard while tapping some keys
multiple times.  This was functional but not so elegant!

I decided to re-learn Vim to use it __properly__.  Here is my learning memo.

## Concept

* Use default vim (minimum configuration, if possible).
  * Use as much native functionalities.
* 50%/60%-keyboard ready.
  * No cursor keys.

## Guiding voice

Here are a few insightful recommendations on the best practices for Vim.

* Voice of Vim God (Vim upstream: Bram Moolenaar): [Seven habits of effective text editing](https://www.moolenaar.net/habits.html)
* Voice of Vim Gurus: [#vim Recommendations](https://www.vi-improved.org/recommendations/)
* Voice of internet mumbling such as
  [vim-galore](https://github.com/mhinz/vim-galore) on which I don't always
  agree.
* [RTFM](https://vimhelp.org/) or type "`vim '+h|only'`".

## NORMAL MODE

Unlike other editors, the existence of NORMAL MODE is what makes Vim as the
great editor which allows the minimum usage of the ALT-key and CTRL-key.

### Cheat sheet

Here is my cheat sheet to remind me of all the important key strokes used
around NORMAL MODE with emphasis on motion keys:

```
 NORMAL MODE:        Goto BOF → gg      r +--- Next Char
 screen                   n N # ?ααα   e / +-- End of Word (non-alnum)
 scroll        ai+wW({[<sp"'`↓  ^B    t / / +- Word Next (non-alnum)
 ↓     Change c{motion} cc  c↑  ^U   n / / / + End of Word (space)
 ↓     Delete d{motion} dd  d↑  H   e / / / / +Word Next (space)
 +--+  Copy   y{motion} yy  y↑  {  C / / / / / +Till α, x  Delete char
 |zt|  Put After/Before p / P   ( / / / / / / / Find α, r  Replace char
 |^e|  "α  Use α as register    k/ / / / / / /  / EOL,  ~  Change case
 |zz|     0 ^ Fα Tα gE B ge b h M l e w E W tα fα $    gd  Goto definiton
 |^y| ↓↓↓ Split Window ↓↓↓      j ←--- Line            ^]  Tag jump
 |zb| ^W + ncsvhjkl=+-_<>|      ) ←--- Sentence        ^T  Tag jump-back
 +--+ Join lines       J        } ←--- Paragraph       ^O  Jump back
      Forward Backward Search   L ←--- Bottom of Page  {visual}>  Indent →
      n N /ααα ?ααα ← Find ααα  ^D ←-- Prev 1/2 Page   {visual}<  Indent ←
      n N *    # ←--- Indicator ^F ←-- Next Page       {visual}=  Indent ⇆
      , ; tα   Tα ←-- Till α    /ααα ← Find ααα * n N  {visual}gq Format Text
      , ; fα   Fα ←-- Find α    G ←--- Goto EOF        :        Command mode
   Next Prev   %  ←-- Match     [{ ]} [[ ]] [] ][ Look for {}
 Record: qα, End-Record: q, Play-Record: @α, Mark as α: mα, Jump to α: `α/'α
 Undo: u, Redo: ^R, Repeat: . , Fold: Open zo/zO/zr/zR, Close zc/zC/zm/zM
 Insert Mode: i/a Before/After Char, I/A Before/After Line, O/o above/below
 Visual Mode: v Char V Line ^V Block, Replace Mode: R, Normal mode: <ESC>
```

This is intentionally terse.

I found some key sequences such as `3w`, `bc$`, `ciw`, `3yaw`, … quite useful,
now.


### Hints for memorizing key strokes

Some key assignments look confusing.  Here are my hints for memorizing such
key strokes.

* Cursor move keys
  * `j` shape points to downward.
  * `k` shape points to upward.
* Screen scroll keys:
  * `^B`: Backward page
  * `^U`: Upward 1/2 page
  * `^Y`: expose up 1 line == Yester(day)-line, next to ^u (Keep cursor)
  * `^F`: Forward  page
  * `^D`: Downward 1/2 page
  * `^E`: Expose down 1 line, next to ^d (Keep cursor)

### Interesting commands

* `ga`: Get Unicode point (HEX etc.)
* `g8`: Get Binary data HEX sequence
* `^G`: Get cursor Position
* `{visual}g?`: ROT13

### Map keys

I map SPACE-key as leader-key in NORMAL MODE since it has no practical use and
easier access than default `\`-key.

```
let mapleader = ' '
```

### Some options

I tend to set as follows in the vim startup file (`~/.vimrc` or its equivalent):

```
" make vim copy buffer bigger (default 50 lines: viminfo='100,<50,s10,h)
set viminfo='100,<5000,s100,h

" Allow to move cursor beyond for block
set virtualedit=block

```

## INSERT MODE and COMMAND MODE

INSERT MODE and COMMAND MODE are intuitive with cursor keys.

INSERT MODE is started from NORMAL MODE by pressing `i`, `I`,`a`,`A`,`o`, `O`,
etc.

COMMAND MODE is started from NORMAL MODE by pressing `:` or `/` or `?`. 

### Cool inputs with `CTRL`-keys

Here are some non-intuitive key sequences used by INSERT MOD used by INSERT
MODE.  Some key sequences with are also valid for COMMAND MODE.

* `^H`: Delete a character before the cursor. (same as `<BS>`)
* `^W`: Delete the word before the cursor. 
* `^U`: Delete all entered characters before the cursor. 
* `^P`: Find previous keyword.(map non-starter `<S-TAB>` to this)
* `^N`: Find next keyword.    (map non-starter `<TAB>` to this)
* `^Y`: Insert the character which is above the cursor. (Only INSERT MODE)
* `^E`: Insert the character which is below the cursor. (Only INSERT MODE)
* `^T`: Insert one shiftwidth of indent. (Only INSERT MODE)
* `^D`: Delete one shiftwidth of indent. (Only INSERT MODE)
* `^D`: List all possible choices. (Only in COMMAND MODE started by `:`)
  wildmenu)
* `^F`: open edittable command history. (only COMMAND MODE)
* `^X`: start of sub-mode (`h: insert_expand`).
* `0^D`: delete all indent.
* `^Vxαα`: insert character at `0xαα`. (command mode)
* `^Vuαααα`: insert unicode character at `0xαααα`. (command mode)
* `^Vuαααααα`: insert unicode character at `0xαααααααα`. (command mode)

You can use NORMAL-MODE-like editing by starting the COMMAND MODE with `q:` or
`q/` or `q?`.  Alternatively, typing `^F` in command mode started by `:` or `/`
or `?` also starts NORMAL-MODE-like editing.

### Map non-starter TAB in INSERT MODE

I map non-starter `TAB` following the vim manual (`:h ins-completion`):

```
" auto complete <c-n> with <tab> in non-bol
"
function! clevertab()
   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
      return "\<tab>"
   else
      return "\<c-n>"
   endif
endfunction
inoremap <tab> <c-r>=clevertab()<cr>
" auto complete <c-p> with <s-tab> in non-bol
"
function! cleverstab()
   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
      return "\<s-tab>"
   else
      return "\<c-p>"
   endif
endfunction
inoremap <S-Tab> <C-R>=CleverSTab()<CR>
```

### TAB in COMMAND MODE

Normally, `TAB` in COMMAND MODE starts wildmenu under `:set wildmenu`.
You can use `TAB` and `S-TAB` to chose the one you want.

### Map to ESC

Pressing `ESC`-key is a bit stressful since it is far from the finger home
position.  I map a quick key sequence of "`kj`" to `ESC`-key.

```
inoremap kj  <Esc>
inoremap kjk kj
```

The second mapping is to allow quick input of "`kj`" by "`kjk`".  Without this,
you need to wait a second after entering "`k`" to enter "`kj`".

("`k`" and "`j`" are easiest to type and unlikely under normal input situation.
I remember this as my __Knee-Jerk-reaction__ to the distant `ESC`-key.)

<!-- vim: set sw=2 sts=2 ai si et tw=79 ft=markdown: -->
