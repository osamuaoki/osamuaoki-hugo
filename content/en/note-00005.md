---
title: "Re-learning Vim (1)"
date: 2019-09-17
categories:
  - vim
  - english
tags:
  - vim
slug: vim-learn-1
---

I could use Vim as a basic editor with TKL-keyboard while tapping some keys
multiple times.  This was functional but not so elegant!

I decided to re-learn Vim to use it __properly__.  Here is my learning memo.

For simplicity, I use `^F` to mean `CTRL-F`.

## Concept

* Use default vim (minimum configuration, if possible).
  * Use as much native functionalities.
  * Don't force Vim to behave like another program.
* 50%/60%-keyboard ready.
  * Use no cursor keys, if possible.

## Guiding voice

Here are a few insightful recommendations on the best practices for Vim.

* Voice of Vim God (Vim upstream: Bram Moolenaar): [Seven habits of effective text editing](https://www.moolenaar.net/habits.html)
* [RTFM](https://vimhelp.org/) or type "`vim '+h|only'`".
* Voice of Vim Gurus: [#vim Recommendations](https://www.vi-improved.org/recommendations/)
* Interesting hints from some people:
  * [Learn Vimscript the Hard Way](http://learnvimscriptthehardway.stevelosh.com/)
  * [vim-galore](https://github.com/mhinz/vim-galore)

## NORMAL MODE

Unlike other editors, the existence of NORMAL MODE is what makes Vim as the
great editor which allows the minimum usage of the ALT-key and CTRL-key.

### Cheat sheet

Here is my cheat sheet to remind me of all the important key strokes used
around NORMAL MODE with emphasis on motion keys:

```
 NORMAL MODE <ESC>:  Goto BOF → gg      r +--- Next Char
 screen                   n N # ?ααα   e / +-- End of Word (non-alnum)
 scroll        ai+wW({[<sp"'`↓  ^B    t / / +- Word Next (non-alnum)
 ↓     Change c{motion} cc  c↑  ^U   n / / / + End of Word (space)
 ↓     Delete d{motion} dd  d↑  H   e / / / / +Word Next (space)
 +--+  Copy   y{motion} yy  y↑  {  C / / / / / +Till α, x  Delete char
 |zt|  Put After/Before p / P   ( / / / / / / / Find α, r  Replace char
 |^e|  "α  Use α as register    k/ / / / / / /  / EOL,  ~  Change case
 |zz|     0 ^ Fα Tα gE B ge b h M l e w E W tα fα $    gd  Goto definiton
 |^y| ↓↓↓ Split Window ↓↓↓      j ←--- Line (J for Join line)   ^]  Tag jump
 |zb| ^W + ncsvhjkl=+-_<>|      ) ←--- Sentence        ^T  Tag jump-back
 +--+                           } ←--- Paragraph       ^I/^O  Jump next/prev
      Forward Backward Search   L ←--- Bottom of Page  {visual}>  Indent →
      n N /ααα ?ααα ← Find ααα  ^D ←-- Prev 1/2 Page   {visual}<  Indent ←
      n N *    # ←--- Indicator ^F ←-- Next Page       {visual}=  Indent ⇆
      , ; tα   Tα ←-- Till α    /ααα ← Find ααα * n N  {visual}gq Format Text
      , ; fα   Fα ←-- Find α    G ←--- Goto EOF        J          Join line
   Next Prev   %  ←-- Match     [{ ]} [[ ]] [] ][ Look for {}
 Record: qα, End-Record: q, Play-Record: @α, Mark as α: mα, Jump to α: `α/'α
 Undo: u, Redo: ^R, Repeat: . , Fold: Open zo/zO/zr/zR, Close zc/zC/zm/zM
 Insert Mode: i/a Before/After Char, I/A Before/After Line, O/o above/below
 Visual Mode: v Char V Line ^V Block, Replace Mode: R, Ex Mode: : or q:
```

This is intentionally terse.  `^` is used as prefix for CTRL-key.

I found some key sequences such as `3w`, `bc$`, `ciw`, `3yaw`, … quite useful,
now.


### Hints for memorizing key strokes

Some key assignments look confusing.  Here are my hints for memorizing such
key strokes.

* Cursor move keys
  * `j` shape points to downward.
  * `k` shape points to upward.
* Screen scroll keys:
  * `^B`: Backward page
  * `^U`: Upward 1/2 page
  * `^Y`: expose up 1 line == Yester(day)-line, next to ^u (Keep cursor)
  * `^F`: Forward  page
  * `^D`: Downward 1/2 page
  * `^E`: Expose down 1 line, next to ^d (Keep cursor)

### Interesting commands

* `ga`: Get Unicode point (HEX etc.)
* `g8`: Get Binary data HEX sequence
* `^G`: Get filename and cursor position
* `g^G`: Get cursor position in column, line, word, character and byte
* `{visual}g?`: ROT13 (Super insecure encryption)

### Map leader key

I map SPACE-key as leader-key in NORMAL MODE since it has no practical use and
easier access than default `\`-key.

```
let mapleader = ' '
```

### Some options

I tend to set as follows in the vim startup file (`~/.vimrc` or its equivalent):

```
" make vim copy buffer bigger (default 50 lines: viminfo='100,<50,s10,h)
set viminfo='100,<5000,s100,h

" Allow to move cursor beyond for block
set virtualedit=block

```

## INSERT MODE and COMMAND MODE

INSERT MODE and COMMAND MODE are intuitive with cursor keys.

INSERT MODE is started from NORMAL MODE by pressing `i`, `I`,`a`,`A`,`o`, `O`,
etc.

COMMAND MODE is started from NORMAL MODE by pressing `:` or `/` or `?`.

You can use NORMAL-MODE-like editing for COMMAND MODE situation by starting it
with `q:` or `q/` or `q?`.  Alternatively, typing `^F` in COMMAND MODE
situation also starts NORMAL-MODE-like editing.

### Map a key sequence to ESC in INSERT MODE

Pressing `ESC`-key to get back to NORMAL MODE from INSERT MODE is a bit
stressful since it is far from the finger home position.  I map a quick key
sequence of "`kj`" to `ESC`-key.

```
inoremap kj  <Esc>
inoremap kjk kj
```

The second mapping is to allow quick input of `kj` by `kjk`.  Without this, you
need to wait a second after entering `k` to enter `kj`.

`k` and `j` are easiest to type and unlikely under normal input situation.  I
remember this as my __Knee-Jerk-reaction__ to the distant `ESC`-key.

### Last resort inputs with `CTRL`-keys

Here are some non-intuitive key sequences used by INSERT MODE used by INSERT
MODE.  Some key sequences are also valid for COMMAND MODE.

* `^H`: Delete a character before the cursor. (same as `<BS>`)
* `^W`: Delete the word before the cursor.
* `^U`: Delete all entered characters before the cursor.
* `^P`: Find previous keyword.(map non-starter `<S-TAB>` to this)
* `^N`: Find next keyword.    (map non-starter `<TAB>` to this)
* `^Y`: Insert the character which is above the cursor. (Only INSERT MODE)
* `^E`: Insert the character which is below the cursor. (Only INSERT MODE)
* `^T`: Insert one shiftwidth of indent. (Only INSERT MODE)
* `^D`: Delete one shiftwidth of indent. (Only INSERT MODE)
* `^D`: List all possible choices. (Only Ex COMMAND MODE to start wildmenu)
* `^F`: open editable command history. (only COMMAND MODE)
* `^X`: start of sub-mode (`h: insert_expand`).
* `0^D`: delete all indent.
* `^Vxαα`: insert character at `0xαα`. (command mode)
* `^Vuαααα`: insert unicode character at `0xαααα`. (command mode)
* `^Vuαααααα`: insert unicode character at `0xαααααααα`. (command mode)

Although it is tempting to map some CONTROL-key sequences to some cursor keys,
don't bother to do so since they are most likely used by Vim.  Use NORMAL MODE
and COMMAND NORMAL MODE and native cursor keys.

### Map non-starter TAB in INSERT MODE

I map non-starter `TAB` following the vim manual (`:h ins-completion`):

```vim
" auto complete <c-n> with <tab> in non-bol
"
function! clevertab()
   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
      return "\<tab>"
   else
      return "\<c-n>"
   endif
endfunction
inoremap <tab> <c-r>=clevertab()<cr>
" auto complete <c-p> with <s-tab> in non-bol
"
function! cleverstab()
   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
      return "\<s-tab>"
   else
      return "\<c-p>"
   endif
endfunction
inoremap <S-Tab> <C-R>=CleverSTab()<CR>
```

### TAB in COMMAND MODE

Normally, `TAB` in COMMAND MODE starts __wildmenu__ under `:set wildmenu`.  You
can use `TAB` and `S-TAB` to chose the one you want.

### Basics in COMMAND MODE

* `:e ααα`: Edit ααα file
* `:w`: Write file
* `:wall`: Write all file
* `:up[date]`: Write all modified
* `:wq`: Write and Quit
* `:q!`: Quit (force)
* `:bα`: Edit buffer α
* `:bn`: Edit next buffer
* `:bp`: Edit previous buffer
* `:cw`: Open quickfix window
* `:cn`: Jump to next quickfix item
* `:cp`: Jump to previous quickfix item
* `:r ααα`: Read ααα file to cursor
* `:r! ααα`: Read ααα command output to cursor
* `:%s/ααα/βββ/gc`: Replace ααα with βββ for all lines with confirmation
* `:bufdo ααα`: Execute ααα in each buffer in the buffer list.

Use `|` as in-line command separator.

## QUICKFIX MODE

If you have a task to search some text to make Vim to jump to particular places
in its buffer, QUICKFIX MODE is the one to automate your process.  No more
`grep` on another terminal window.

There are 4 basic commands to start preparing jump list data.

* `:mak[e]`: Run `make` for compile-jump-edit cycle. (`:h :make`)
* `:gr[ep]`: Run system-`grep` for search-jump-edit cycle. (`:h :grep`)
* `:vim[grep]`: Run internal-`grep` for search-jump-edit cycle. (`:h :vimgrep`)
* `:helpg[rep]`: Run internal-`grep` on all help text files for
  search-jump-read cycle. (`:h :helpgrep`)

Then you access and use the jump list.

* `:cope[n]`: Open a window to show the current list of errors.
* `:ccl[ose]`: Close a window for the jump list.
* `:cw[indow]`: Open the quickfix window if error.  Otherwise, close the quickfix
  window.
* `:cn[ext]`: Jump to next quickfix item location.
* `:cp[rev]`: Jump to previous quickfix item location.

Please note there are `l...` variants of above commands.

## TERMINAL MODE

This is a new Vim/NVim feature.  Now capturing shell session is as easy.  No
more envying EMACS terminal mode.

 * `:ter[minal]`: Start TERMINAL MODE. (`:h :terminal`)
 * `^WN` or `^\^N`: Switch to TERMINAL-NORMAL MODE.
 * `^W^W`: Move focus to the next window
 * `^W:`: Enter an Ex COMMAND MODE.
 * `^W.`: Send a `^W` to the job in the terminal.
 * `^W^\`: Send a `^\` to the job in the terminal.
 * `^W^C`: Send a `^C` to the job in the terminal.

Typing `i` etc. will get you back to TERMINAL MODE from TERMINAL-NORMAL MODE.

### Map a key sequence to `^WN` in TERMINAL MODE

Similar key sequence trick proposed for INSERT MODE can also be implemented
```
tnoremap kj  <C-W>N
tnoremap kjk kj
```

<!-- vim: set sw=2 sts=2 ai si et tw=79 ft=markdown: -->
