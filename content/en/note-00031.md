---
title: "Re-learning Vim (4)"
date: 2022-07-15T00:00:00+00:00
categories:
  - desktop
  - english
tags:
  - vim
slug: vim-learn-4
---

## Neovim 0.7 migration

After short trial of **Neovim** (nvim) 0.5 described in [Re-learning Vim
(3)]({{< ref "note-00027.md" >}}), I went back to the good old **Vim** with
ALE.

As I find out [Neovim](https://neovim.io/) (nvim) 0.7 now has native LSP
support and tools around it seems to be getting mature, I decided to check nvim
with lua again. I also found a nice recent review:

* [The best IDE-style configurations for nvim](https://galexbh.hashnode.dev/the-best-ide-style-configurations-for-nvim)

Then I checked code size etc on IDE system:

* DOOM-NVIM (572K effective code)
  * SRC: https://github.com/NTBBloodbath/doom-nvim
* LunarVim (452K effective code)
  * SRC: https://github.com/LunarVim/LunarVim
  * HOME: https://www.lunarvim.org/#opinionated
* AstroNvim (316K effective code)
  * SRC: https://github.com/AstroNvim/AstroNvim
  * HOME: https://astronvim.github.io/
* NvChad (108K effective code)
  * SRC: https://github.com/NvChad/NvChad
  * WIKI: https://github.com/NvChad/NvChad/wiki (old)
  * HOME: https://nvchad.netlify.app/

Since AstroNvim seems to be most interesting for its compactness and
pre-configured package settings, I tried it as the main `nvim` configuration.
I also installed LunarVim since it creates the `lvim` command which doesn't
interfere with the normal `nvim` execution.  These can co-exist.

All these already use delayed loading etc., to save their start up time.  That
is not what I am focused any more.  My focus is now the out-of-box usability
and the ease of configuration.

## Syntax checker

If I install `shellcheck`, both AstroNvim and LunarVim display error messages.
Nice out of box configuration.

## Internals of AstroNvim

Let me record how I looked into the internals of AstroNvim for its user
configuration.  Let me assume there is a user configuration file at
`~/.config/astronvim/user/init.lua` for simplicity.

### Prerequisite

See [Getting started using Lua in
Neovim](https://github.com/nanotee/nvim-lua-guide) and its linked documents
first.

### Value of vim option and `runtimepath`

We can inspect the actual internal option value of running nvim from the nvim
command mode.  The actual vim `runtimepath` option from lua's point of view can
be inspected by:

```lua
:lua print(vim.inspect(vim.opt.runtimepath))
```

It is impossible to read so much output and make any sense.  Here, `:redir` can
be used to ease reading of these by capturing output in a file. (The use of
`:sirent` kills pager prompt.)

```lua
:redir > rtp.txt
:silent lua print(vim.inspect(vim.opt.runtimepath))
:redir END
```

Now we know `scope = "global"`, `shortname = "rtp"`, etc.  We can always use
short name, too.

If we need its current value only,  it can be inspected and presented in lua
table by:

```lua
:lua print(vim.inspect(vim.opt.rtp:get()))
```

Alternatively since we now know it is a global option, it can be accessed and
presented in similar way as vim classic `:set rtp?` style by:

```lua
:lua print(vim.go.rtp)
```

From this output, we can confirm `rtp` to be scanned roughly as follows.

* `/home/<username>/.config/nvim`
* `/home/<username>/.local/share/nvim/site/pack/packer/opt/*`
* `/home/<username>/.local/share/nvim/site/pack/packer/opt/*/after`
* `/home/<username>/.config/nvim/after`
* `/home/<username>/.config/astronvim`

The notable point is the last one specially inserted by AstroNvim.

This allows us to move `lua/user/` directory out of `~/config/nvim` to
`~/config/astronvim`.

### Tracing source code of AstroNvim

Let's try to trace source code of AstroNvim to understand how to customize it.

### Entry point: `init.lua`

The entry point of nvim is `/home/<username>/.config/nvim/init.lua`.  It is
simply as:

```lua
local impatient_ok, impatient = pcall(require, "impatient")
if impatient_ok then impatient.enable_profile() end

for _, source in ipairs {
  "core.utils",
  "core.options",
  "core.bootstrap",
  "core.plugins",
  "core.autocmds",
  "core.mappings",
  "core.ui",
  "configs.which-key-register",
} do
  local status_ok, fault = pcall(require, source)
  if not status_ok then vim.api.nvim_err_writeln("Failed to load " .. source .. "\n\n" .. fault) end
end

astronvim.conditional_func(astronvim.user_plugin_opts("polish", nil, false))
```

The first few lines are for
[impatient.nvim](https://github.com/lewis6991/impatient.nvim.git) package.  Its
one of the package installed in
`/home/<username>/.local/share/nvim/site/pack/packer/start/` together with
[packer.nvim](https://github.com/wbthomason/packer.nvim) and
[popup.nvim](https://github.com/nvim-lua/popup.nvim.git).  These are loaded
automatically upon starting nvim.

`impatient.nvim` speeds up loading Lua modules in Neovim to improve startup time.

Then loop over `source` to set up AstroNvim's upstream configured system.
We will get back to these.

The last line is entry point for the user configuration.  So we need to find
out followings:

* Variable: `astronvim`
* Function: `conditional_func`
* Function: `user_plugin_opts`

### Variable `astronvim`

The `astronvim` is the globally accessible variable within AstroNvim 
defined originally in `utils/init.lua` as:

```lua
_G.astronvim = {}
```

We can inspect its current value as:

```lua
:lua print(vim.inspect(astronvim))
```

(It is too big to paste here but it is full of important informaion)

### Function: `conditional_func`

This is a simple function defined in `lua/core/utils/init.lua`

```lua
function astronvim.conditional_func(func, condition, ...)
  if (condition == nil and true or condition) and type(func) == "function" then return func(...) end
end
```

* If `condition` is not specified, and if `func` is the function type, return `func(...)`.
* If `condition` exists and is met, and if `func` is the function type, return `func(...)`.

The above case is, `condition`=`nil` and `...` is `nil`.

So this simply calls `astrovim.user_plugin_opts("polish", nil, false)` here.

### Function: `user_plugin_opts`

This is a function defined in `lua/core/utils/init.lua`

```lua
function astronvim.user_plugin_opts(module, default, extend, prefix)
  if extend == nil then extend = true end
  default = default or {}
  local user_settings = load_module_file((prefix or "user") .. "." .. module)
  if user_settings == nil and prefix == nil then user_settings = user_setting_table(module) end
  if user_settings ~= nil then default = func_or_extend(user_settings, default, extend) end
  return default
end
```
Since it is:
* `module="polish"`
* `default=nil`
* `extend=false`
* `prefix=nil`

The function processes essentially as:

```lua
  module="polish"
  default = {}
  extend=false
  prefix=nil
  local user_settings = load_module_file("user.polish")
    -- nil with ~/.config/astrovim/usr/init.lua only configuration
  if user_settings == nil then user_settings = user_setting_table("polish") end
    -- load ~/.config/astrovim/usr/init.lua and return "polish" as
    -- user_settings
  if user_settings ~= nil then default = func_or_extend(user_settings, default, extend) end
    -- update default by user_settings in polish 
  return default
```

Here, we need to look into 3 local functions to get to the above conclusion:
* Function: `load_module_file`
* Function: `user_setting_table`
* Function: `func_or_exten`

Let me read `lua/core/utils/init.lua` from the top by adding comment to the
source.

```lua
... -- short hand definition etc.

astronvim.install = { home = stdpath "config" } -- ~/.config/nvim
astronvim.install.config = stdpath("config"):gsub("nvim$", "astronvim") -- ~/.config/`astronvim
vim.opt.rtp:append(astronvim.install.config) -- extend rtp to include ~/.config/astronvim
local supported_configs = { astronvim.install.home, astronvim.install.config }
 -- support both ~/.config/nvim and ~/.config/`astronvim

local function load_module_file(module)
  local found_module = nil
  for _, config_path in ipairs(supported_configs) do -- loop over 2 install path
    local module_path = config_path .. "/lua/" .. module:gsub("%.", "/") .. ".lua"
      -- module name with "." -> directory path with "/".
    if vim.fn.filereadable(module_path) == 1 then found_module = module_path end
  end
  if found_module then -- if module file exists, load it safely with pcall.
    local status_ok, loaded_module = pcall(require, module)
    if status_ok then
      found_module = loaded_module
    else
      astronvim.notify("Error loading " .. found_module, "error")
    end
  end
  return found_module
end

astronvim.user_settings = load_module_file "user.init" -- load "user.init"
astronvim.default_compile_path = stdpath "data" .. "/packer_compiled.lua" -- ~/.local/share/nvim/acker_compiled.lua

...

local function func_or_extend(overrides, default, extend)
  if extend then -- false for this part of code run
    if type(overrides) == "table" then
      default = vim.tbl_deep_extend("force", default, overrides)
    elseif type(overrides) == "function" then
      default = overrides(default)
    end
  elseif overrides ~= nil then
    default = overrides
  end
  return default
end

...

local function user_setting_table(module)
  local settings = astronvim.user_settings or {}
  for tbl in string.gmatch(module, "([^%.]+)") do
    settings = settings[tbl]
    if settings == nil then break end
  end
  return settings
end
```



## Customization

I added some features.

* Toggle line number
* Toggle toggle_signcolumn 
* ...

cmp needs some more work and code needs to be cleaned.

https://github.com/AstroNvim/AstroNvim/issues/763

I think I need to clean up using tricks discussed:
https://www.reddit.com/r/neovim/comments/v8d3lx/astronvim_v140/
https://astronvim.github.io/configuration/basic_configuration#example-user-configuration
https://astronvim.github.io/configuration/override_formats#override-table
https://astronvim.github.io/configuration/override_formats#override-function

## Terminal settings and modifier keys

As before, set `DEL`-code(0x7F) for Backspace and use escape sequence for Delete.
This frees the ASCII `BS` (CTRL-H) code so window jump can be mapped to `<C-H>`.

Neovim 0.7 now correctly distinguishes modifier key combos in its own
input processing, so users can now map e.g. `<Tab>` and `<C-I>` separately.

<!-- vim: set sw=4 sts=4 ai si et tw=79 ft=markdown: -->
